// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v3.19.1
// source: antelope.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "sf.antelope.type.v1";

export enum BlockReversibility {
  /** BLOCKREVERSIBILITY_NONE - there is no block */
  BLOCKREVERSIBILITY_NONE = 0,
  BLOCKREVERSIBILITY_REVERSIBLE = 1,
  BLOCKREVERSIBILITY_IRREVERSIBLE = 2,
  BLOCKREVERSIBILITY_STALE = 3,
  /** BLOCKREVERSIBILITY_MAYBESTALE - behind lib, but we have not confirmed irreversibility */
  BLOCKREVERSIBILITY_MAYBESTALE = 4,
  UNRECOGNIZED = -1,
}

export function blockReversibilityFromJSON(object: any): BlockReversibility {
  switch (object) {
    case 0:
    case "BLOCKREVERSIBILITY_NONE":
      return BlockReversibility.BLOCKREVERSIBILITY_NONE;
    case 1:
    case "BLOCKREVERSIBILITY_REVERSIBLE":
      return BlockReversibility.BLOCKREVERSIBILITY_REVERSIBLE;
    case 2:
    case "BLOCKREVERSIBILITY_IRREVERSIBLE":
      return BlockReversibility.BLOCKREVERSIBILITY_IRREVERSIBLE;
    case 3:
    case "BLOCKREVERSIBILITY_STALE":
      return BlockReversibility.BLOCKREVERSIBILITY_STALE;
    case 4:
    case "BLOCKREVERSIBILITY_MAYBESTALE":
      return BlockReversibility.BLOCKREVERSIBILITY_MAYBESTALE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockReversibility.UNRECOGNIZED;
  }
}

export function blockReversibilityToJSON(object: BlockReversibility): string {
  switch (object) {
    case BlockReversibility.BLOCKREVERSIBILITY_NONE:
      return "BLOCKREVERSIBILITY_NONE";
    case BlockReversibility.BLOCKREVERSIBILITY_REVERSIBLE:
      return "BLOCKREVERSIBILITY_REVERSIBLE";
    case BlockReversibility.BLOCKREVERSIBILITY_IRREVERSIBLE:
      return "BLOCKREVERSIBILITY_IRREVERSIBLE";
    case BlockReversibility.BLOCKREVERSIBILITY_STALE:
      return "BLOCKREVERSIBILITY_STALE";
    case BlockReversibility.BLOCKREVERSIBILITY_MAYBESTALE:
      return "BLOCKREVERSIBILITY_MAYBESTALE";
    case BlockReversibility.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionStatus {
  TRANSACTIONSTATUS_NONE = 0,
  TRANSACTIONSTATUS_EXECUTED = 1,
  TRANSACTIONSTATUS_SOFTFAIL = 2,
  TRANSACTIONSTATUS_HARDFAIL = 3,
  TRANSACTIONSTATUS_DELAYED = 4,
  TRANSACTIONSTATUS_EXPIRED = 5,
  TRANSACTIONSTATUS_UNKNOWN = 6,
  TRANSACTIONSTATUS_CANCELED = 7,
  UNRECOGNIZED = -1,
}

export function transactionStatusFromJSON(object: any): TransactionStatus {
  switch (object) {
    case 0:
    case "TRANSACTIONSTATUS_NONE":
      return TransactionStatus.TRANSACTIONSTATUS_NONE;
    case 1:
    case "TRANSACTIONSTATUS_EXECUTED":
      return TransactionStatus.TRANSACTIONSTATUS_EXECUTED;
    case 2:
    case "TRANSACTIONSTATUS_SOFTFAIL":
      return TransactionStatus.TRANSACTIONSTATUS_SOFTFAIL;
    case 3:
    case "TRANSACTIONSTATUS_HARDFAIL":
      return TransactionStatus.TRANSACTIONSTATUS_HARDFAIL;
    case 4:
    case "TRANSACTIONSTATUS_DELAYED":
      return TransactionStatus.TRANSACTIONSTATUS_DELAYED;
    case 5:
    case "TRANSACTIONSTATUS_EXPIRED":
      return TransactionStatus.TRANSACTIONSTATUS_EXPIRED;
    case 6:
    case "TRANSACTIONSTATUS_UNKNOWN":
      return TransactionStatus.TRANSACTIONSTATUS_UNKNOWN;
    case 7:
    case "TRANSACTIONSTATUS_CANCELED":
      return TransactionStatus.TRANSACTIONSTATUS_CANCELED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionStatus.UNRECOGNIZED;
  }
}

export function transactionStatusToJSON(object: TransactionStatus): string {
  switch (object) {
    case TransactionStatus.TRANSACTIONSTATUS_NONE:
      return "TRANSACTIONSTATUS_NONE";
    case TransactionStatus.TRANSACTIONSTATUS_EXECUTED:
      return "TRANSACTIONSTATUS_EXECUTED";
    case TransactionStatus.TRANSACTIONSTATUS_SOFTFAIL:
      return "TRANSACTIONSTATUS_SOFTFAIL";
    case TransactionStatus.TRANSACTIONSTATUS_HARDFAIL:
      return "TRANSACTIONSTATUS_HARDFAIL";
    case TransactionStatus.TRANSACTIONSTATUS_DELAYED:
      return "TRANSACTIONSTATUS_DELAYED";
    case TransactionStatus.TRANSACTIONSTATUS_EXPIRED:
      return "TRANSACTIONSTATUS_EXPIRED";
    case TransactionStatus.TRANSACTIONSTATUS_UNKNOWN:
      return "TRANSACTIONSTATUS_UNKNOWN";
    case TransactionStatus.TRANSACTIONSTATUS_CANCELED:
      return "TRANSACTIONSTATUS_CANCELED";
    case TransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ActionTraces {
  actionTraces: ActionTrace[];
}

export interface TransactionTraces {
  transactionTraces: TransactionTrace[];
}

export interface DBOps {
  dbOps: DBOp[];
}

export interface Block {
  /** id is the block's hash. */
  id: string;
  /** Number is the block's height at which this block was mined. */
  number: number;
  version: number;
  /**
   * Header contains the block's header information like its parent hash, the merkel root hash
   * and all other information the form a block.
   */
  header: BlockHeader | undefined;
  producerSignature: string;
  blockExtensions: Extension[];
  dposProposedIrreversibleBlocknum: number;
  dposIrreversibleBlocknum: number;
  blockrootMerkle: BlockRootMerkle | undefined;
  producerToLastProduced: ProducerToLastProduced[];
  producerToLastImpliedIrb: ProducerToLastImpliedIRB[];
  confirmCount: number[];
  pendingSchedule: PendingProducerSchedule | undefined;
  activatedProtocolFeatures: ActivatedProtocolFeatures | undefined;
  validated: boolean;
  /**
   * to be used during Legacy to Savanna transition where action_mroot
   * needs to be converted from Legacy merkle to Savanna merkle
   */
  actionMrootSavanna: Uint8Array;
  /** the LIB post-Savanna activation, pre-Savanna this is found in dpos_irreversible_blocknum */
  finalityLib: number;
  finalityData: FinalityData | undefined;
  proposerPolicy: ProposerPolicy | undefined;
  finalizerPolicy: FinalizerPolicy | undefined;
  rlimitOps: RlimitOp[];
  /**
   * The unfiltered transactions in this block when NO filtering has been applied,
   * (i.e. `filtering_applied = false`). When filtering has been applied on this block,
   * (i.e. `filtering_applied = true`), this field will be set to `nil` and instead, the
   * `filtered_transactions` will be populated with only filtered transactions.
   *
   * Use the helper getter method `Transactions()` to automatically pick the correct
   * field to use (`unfiltered_transactions` when `filtering_applied == false` and
   * `filtered_transactions` when `filtering_applied == true`).
   */
  unfilteredTransactions: TransactionReceipt[];
  /**
   * The filtered transactions in this block when filtering has been applied,
   * (i.e. `filtering_applied = true`). This will be only the transactions
   * that matched the include filter CEL expression and did NOT match the exclude
   * filter CEL expression.
   *
   * Use the helper getter method `Transactions()` to automatically the correct
   * field (`unfiltered_transaction` when `filtering_applied == false` and
   * `filtered_transactions` when `filtering_applied == true`).
   */
  filteredTransactions: TransactionReceipt[];
  /**
   * Number of transaction executed within this block when no filtering
   * is applied (`filtering_applied == false`).
   */
  unfilteredTransactionCount: number;
  /**
   * Number of transaction that were successfully executed within this block that are found in
   * the `filtered_transactions` array. This field is populated only when the flag
   * `filtering_applied` is `true`.
   */
  filteredTransactionCount: number;
  /**
   * The unfiltered implicit transaction ops in this block when NO filtering has been applied,
   * (i.e. `filtering_applied = false`). When filtering has been applied on this block,
   * (i.e. `filtering_applied = true`), this field will be set to `nil` and instead, the
   * `filtered_implicit_transaction_ops` will be populated with only filtered implicit
   * transaction ops.
   *
   * Use the helper getter method `ImplicitTransactionOps()` to automatically pick the correct
   * field to use (`unfiltered_implicit_transaction_ops` when `filtering_applied == false` and
   * `filtered_implicit_transaction_ops` when `filtering_applied == true`).
   */
  unfilteredImplicitTransactionOps: TrxOp[];
  /**
   * The filtered implicit transaction ops in this block when filtering has been applied,
   * (i.e. `filtering_applied = true`). This will be only the implicit transaction ops
   * that matched the include filter CEL expression and did NOT match the exclude
   * filter CEL expression.
   *
   * Use the helper getter method `ImplicitTransactionOps()` to automatically the correct
   * field (`unfiltered_implicit_transaction_ops` when `filtering_applied == false` and
   * `filtered_implicit_transaction_ops` when `filtering_applied == true`).
   */
  filteredImplicitTransactionOps: TrxOp[];
  /**
   * The unfiltered transaction traces in this block when NO filtering has been applied,
   * (i.e. `filtering_applied = false`). When filtering has been applied on this block,
   * (i.e. `filtering_applied = true`), this field will be set to `nil` and instead, the
   * `filtered_transaction_traces` will be populated with only filtered transactions.
   *
   * Use the helper getter method `TransactionTraces()` to automatically pick the correct
   * field to use (`unfiltered_transaction_traces` when `filtering_applied == false` and
   * `filtered_transaction_traces` when `filtering_applied == true`).
   */
  unfilteredTransactionTraces: TransactionTrace[];
  /**
   * The filtered transaction traces in this block when filtering has been applied,
   * (i.e. `filtering_applied = true`). This will be only the transaction trace
   * that matched the include filter CEL expression and did NOT match the exclude
   * filter CEL expression.
   *
   * Use the helper getter method `TransactionTraces()` to automatically pick the correct
   * field to use (`unfiltered_transaction_traces` when `filtering_applied == false` and
   * `filtered_transaction_traces` when `filtering_applied == true`).
   */
  filteredTransactionTraces: TransactionTrace[];
  /**
   * Number of transaction trace executed within this block when no filtering
   * is applied (`filtering_applied == false`).
   */
  unfilteredTransactionTraceCount: number;
  /**
   * Number of transaction trace that were successfully executed within this block that are found in
   * the `filtered_transaction_traces` array. This field is populated only when the flag
   * `filtering_applied` is `true`.
   */
  filteredTransactionTraceCount: number;
  /**
   * Number of top-level actions that were successfully executed within this block when no filtering
   * is applied (`filtering_applied == false`).
   */
  unfilteredExecutedInputActionCount: number;
  /**
   * Number of top-level actions that were successfully executed within this block that are found in
   * the `filtered_transaction_traces` array. This field is populated only when the flag
   * `filtering_applied` is `true`.
   */
  filteredExecutedInputActionCount: number;
  /**
   * Number of actions that were successfully executed within this block when no filtering
   * is applied (`filtering_applied == false`).
   */
  unfilteredExecutedTotalActionCount: number;
  /**
   * Number of actions that were successfully executed within this block that are found in
   * the `filtered_transaction_traces` array. This field is populated only when the flag
   * `filtering_applied` is `true`.
   */
  filteredExecutedTotalActionCount: number;
  /**
   * This was a single string element representing a public key (eos-go#ecc.PublicKey).
   * It has been replaced by `valid_block_signing_authority_v2`.
   * deprecated
   */
  blockSigningKey: string;
  /**
   * This was a list of `{name, publicKey}` elements, each block being signed by a single key,
   * the schedule was simply a list of pair, each pair being the producer name and it's public key
   * used to sign the block.
   */
  activeScheduleV1:
    | ProducerSchedule
    | undefined;
  /**
   * This replaces `block_signing_key` with a richer structure
   * able to handle the weighted threshold multisig for block producers.
   *
   * This can be downgraded to the old `block_signing_key` simply by taking
   * the first key present in the list. This is of course simple and not
   * accurate anymore in EOSIO 2.0 system where `WTMSIG_BLOCK_SIGNATURES`
   * has been activated AND block producers starts signing blocks with
   * more than one key.
   *
   * See BlockSigningAuthority for further details
   */
  validBlockSigningAuthorityV2:
    | BlockSigningAuthority
    | undefined;
  /**
   * This replaces the old type `ProducerSchedule` for the `active_schedule`
   * field. This was only a type change in EOSIO 2.0, the field's name remained
   * the same.
   *
   * This is the new schedule data layout which is richer than it's oldest
   * counterpart. The inner element for a producer can then be composed with
   * multiple keys, each with their own weight and the threshold required to
   * accept the block signature.
   */
  activeScheduleV2:
    | ProducerAuthoritySchedule
    | undefined;
  /**
   * Wheter or not a filtering process was run on this block. The filtering process sets to nil
   * the `unfiltered_transaction_traces` to `nil` and populate the `filtered_transaction_traces`
   * according to the `filtering_include_filter_expr` and `filtering_exclude_filter_expr` CEL
   * expressions. A transaction will be present in the `filtered_transaction_traces` array if
   * it matched the `filtering_include_filter_expr` and did *NOT* match the `filtering_exclude_filter_expr`.
   *
   * Moreover, each matching action that brought the transaction to be in `filtered_transaction_traces`
   * array will have a `filtering_matched` flag set on it to broadcast the fact that this action
   * match the inclusion/exclusion list.
   *
   * This flag controls all `filtered_*` and `unfiltered_*` elements on the Block structure and on
   * substructures if present.
   */
  filteringApplied: boolean;
  /**
   * The CEL filter expression used to include transaction in `filtered_transaction_traces` array, works
   * in combination with `filtering_exclude_filter_expr` value.
   */
  filteringIncludeFilterExpr: string;
  /**
   * The CEL filter expression used to exclude transaction in `filtered_transaction_traces` array, works
   * in combination with `filtering_include_filter_expr` value.
   */
  filteringExcludeFilterExpr: string;
  /**
   * The CEL filter expression used to include system actions, required by some systems, works
   * in combination with the two other filters above.
   */
  filteringSystemActionsIncludeFilterExpr: string;
}

export interface FinalityData {
  majorVersion: number;
  minorVersion: number;
  activeFinalizerPolicyGeneration: number;
  actionMroot: Uint8Array;
  reversibleBlocksMroot: Uint8Array;
  latestQcClaimBlockNum: number;
  latestQcClaimFinalityDigest: Uint8Array;
  latestQcClaimTimestamp: Date | undefined;
  baseDigest: Uint8Array;
  pendingFinalizerPolicy: FinalizerPolicy | undefined;
  lastPendingFinalizerPolicyGeneration: number;
}

export interface FinalizerPolicy {
  generation: number;
  threshold: number;
  finalizers: FinalizerAuthority[];
}

export interface FinalizerAuthority {
  description: string;
  weight: number;
  publicKey: string;
}

/**
 * BlockWithRefs is a lightweight block, with traces and transactions
 * purged from the `block` within, and only.  It is used in transports
 * to pass block data around.
 */
export interface BlockWithRefs {
  id: string;
  block:
    | Block
    | undefined;
  /** TODO: Triple check that that's the right thing */
  implicitTransactionRefs: TransactionRefs | undefined;
  transactionRefs: TransactionRefs | undefined;
  transactionTraceRefs: TransactionRefs | undefined;
  irreversible: boolean;
}

export interface TransactionRefs {
  hashes: Uint8Array[];
}

export interface ActivatedProtocolFeatures {
  protocolFeatures: Uint8Array[];
}

export interface PendingProducerSchedule {
  scheduleLibNum: number;
  scheduleHash: Uint8Array;
  /**
   * See Block#active_schedule_v1 for further details, this is the same change
   * as the active schedule, but applied to the pending field.
   */
  scheduleV1:
    | ProducerSchedule
    | undefined;
  /**
   * See Block#active_schedule_v2 for further details, this is the same change
   * as the active schedule, but applied to the pending field.
   */
  scheduleV2: ProducerAuthoritySchedule | undefined;
}

/** Present in EOSIO 1.x only */
export interface ProducerSchedule {
  version: number;
  producers: ProducerKey[];
}

/** Present in EOSIO 1.x only */
export interface ProducerKey {
  accountName: string;
  blockSigningKey: string;
}

/**
 * Present in EOSIO 2.x only
 *
 * This is the new schedule data layout which is richer than it's oldest
 * counterpart. The inner element for a producer can then be composed with
 * multiple keys, each with their own weight and the threshold required to
 * accept the block signature.
 */
export interface ProducerAuthoritySchedule {
  version: number;
  producers: ProducerAuthority[];
}

/** Present in EOSIO 2.x only */
export interface ProducerAuthority {
  accountName: string;
  blockSigningAuthority: BlockSigningAuthority | undefined;
}

export interface ProposerPolicy {
  activeTime: Date | undefined;
  proposerSchedule: ProducerAuthoritySchedule | undefined;
}

/**
 * Present in EOSIO 2.x only
 *
 * This represents the signatures that were used to signed the block. Previously,
 * in EOSIO 1.x, this was a simple public key since only one key could sign a block.
 * In EOSIO 2.x, when `WTMSIG_BLOCK_SIGNATURES` feature is active, the block can be
 * signed with a set of different public keys, each with its own weight as well as
 * the threshold at which point the signatures are accepted.
 *
 * This is actually implemented as a `fc::variant` type in the C++ code, this tainted
 * our own implementation where multiple types can be represented using a `oneof`.
 *
 * Know current types (and version they were introduced):
 * - `BlockSigningAuthorityV0` [Type 0] (EOSIO 2.0)
 */
export interface BlockSigningAuthority {
  v0?: BlockSigningAuthorityV0 | undefined;
}

/** Present in EOSIO 2.x only */
export interface BlockSigningAuthorityV0 {
  threshold: number;
  keys: KeyWeight[];
}

export interface BlockRootMerkle {
  nodeCount: number;
  activeNodes: Uint8Array[];
}

export interface ProducerToLastProduced {
  name: string;
  lastBlockNumProduced: number;
}

export interface ProducerToLastImpliedIRB {
  name: string;
  lastBlockNumProduced: number;
}

export interface TransactionReceipt {
  id: string;
  /** within the SignedBlock */
  index: number;
  status: TransactionStatus;
  cpuUsageMicroSeconds: number;
  netUsageWords: number;
  /** present if not deferred */
  packedTransaction: PackedTransaction | undefined;
}

export interface PackedTransaction {
  signatures: string[];
  compression: number;
  packedContextFreeData: Uint8Array;
  packedTransaction: Uint8Array;
}

export interface BlockHeader {
  timestamp: Date | undefined;
  producer: string;
  /** uint16 */
  confirmed: number;
  previous: string;
  transactionMroot: Uint8Array;
  actionMroot: Uint8Array;
  scheduleVersion: number;
  headerExtensions: Extension[];
  decodedHeaderExtensions: BlockHeaderExtension[];
  /**
   * EOSIO 1.x only
   *
   * A change to producer schedule was reported as a `NewProducers` field on the
   * `BlockHeader` in EOSIO 1.x. In EOSIO 2.x, when feature `WTMSIG_BLOCK_SIGNATURES`
   * is activated, the `NewProducers` field is not present anymore and the schedule change
   * is reported through a `BlockHeaderExtension` on the the `BlockHeader` struct.
   *
   * If you need to access the old value, you can
   */
  newProducersV1: ProducerSchedule | undefined;
}

export interface BlockHeaderExtension {
  protocolFeatureActivationExtension?: ProtocolFeatureActivationExtension | undefined;
  producerScheduleChangeExtension?: ProducerScheduleChangeExtension | undefined;
}

export interface ProtocolFeatureActivationExtension {
  protocolFeatures: Uint8Array[];
}

export interface ProducerScheduleChangeExtension {
  producerSchedule: ProducerAuthoritySchedule | undefined;
}

/**
 * TransactionEvent are elements that contribute to a view of the
 * whole transaction lifecycle. They can be extracted from block logs,
 * or from storage, and merged together to form an up-to-date
 * TransactionLifecycle.
 */
export interface TransactionEvent {
  id: string;
  blockId: string;
  blockNum: number;
  irreversible: boolean;
  internalAddition?: TransactionEvent_AddedInternally | undefined;
  addition?: TransactionEvent_Added | undefined;
  execution?: TransactionEvent_Executed | undefined;
  dtrxScheduling?: TransactionEvent_DtrxScheduled | undefined;
  dtrxCancellation?: TransactionEvent_DtrxCanceled | undefined;
}

/**
 * This is an implicit transaction, like `onblock` and `onerror` that is extracted
 * separately from the block itself.
 * TODO: does it have a receipt? It probably has
 */
export interface TransactionEvent_AddedInternally {
  transaction: SignedTransaction | undefined;
}

/** This is the transaction that is added into a block, in the list of transactions there. */
export interface TransactionEvent_Added {
  receipt: TransactionReceipt | undefined;
  transaction: SignedTransaction | undefined;
  publicKeys: PublicKeys | undefined;
}

/** Executed contributes the traces of executions */
export interface TransactionEvent_Executed {
  trace: TransactionTrace | undefined;
  blockHeader: BlockHeader | undefined;
}

export interface TransactionEvent_DtrxScheduled {
  createdBy: ExtDTrxOp | undefined;
  transaction: SignedTransaction | undefined;
}

export interface TransactionEvent_DtrxCanceled {
  canceledBy: ExtDTrxOp | undefined;
}

export interface PublicKeys {
  publicKeys: string[];
}

export interface TransactionLifecycle {
  id: string;
  transactionStatus: TransactionStatus;
  /** FIXME: this is currently missing from our data */
  transactionReceipt: TransactionReceipt | undefined;
  transaction: SignedTransaction | undefined;
  publicKeys: string[];
  executionTrace: TransactionTrace | undefined;
  executionBlockHeader: BlockHeader | undefined;
  createdBy: ExtDTrxOp | undefined;
  canceledBy: ExtDTrxOp | undefined;
  creationIrreversible: boolean;
  executionIrreversible: boolean;
  cancelationIrreversible: boolean;
}

export interface SignedTransaction {
  transaction: Transaction | undefined;
  signatures: string[];
  contextFreeData: Uint8Array[];
}

export interface Transaction {
  header: TransactionHeader | undefined;
  contextFreeActions: Action[];
  actions: Action[];
  extensions: Extension[];
}

export interface TransactionHeader {
  expiration: Date | undefined;
  refBlockNum: number;
  refBlockPrefix: number;
  maxNetUsageWords: number;
  maxCpuUsageMs: number;
  delaySec: number;
}

export interface TransactionTrace {
  /** SHA-256 (FIPS 180-4) of the FCBUFFER-encoded packed transaction */
  id: string;
  /** Reference to the block number in which this transaction was executed. */
  blockNum: number;
  /** Index within block's unfiltered execution traces */
  index: number;
  /** Reference to the block time this transaction was executed in */
  blockTime:
    | Date
    | undefined;
  /** Reference to the block ID this transaction was executed in */
  producerBlockId: string;
  /** Receipt of execution of this transaction */
  receipt: TransactionReceiptHeader | undefined;
  elapsed: number;
  netUsage: number;
  /**
   * Whether this transaction was taken from a scheduled transactions pool for
   * execution (delayed)
   */
  scheduled: boolean;
  /**
   * Traces of each action within the transaction, including all notified and
   * nested actions.
   */
  actionTraces: ActionTrace[];
  /** Trace of a failed deferred transaction, if any. */
  failedDtrxTrace:
    | TransactionTrace
    | undefined;
  /** Exception leading to the failed dtrx trace. */
  exception: Exception | undefined;
  errorCode: number;
  /** List of database operations this transaction entailed */
  dbOps: DBOp[];
  /** List of deferred transactions operations this transaction entailed */
  dtrxOps: DTrxOp[];
  /**
   * List of feature switching operations (changes to feature switches in
   * nodeos) this transaction entailed
   */
  featureOps: FeatureOp[];
  /** List of permission changes operations */
  permOps: PermOp[];
  /** List of RAM consumption/redemption */
  ramOps: RAMOp[];
  /**
   * List of RAM correction operations (happens only once upon feature
   * activation)
   */
  ramCorrectionOps: RAMCorrectionOp[];
  /** List of changes to rate limiting values */
  rlimitOps: RlimitOp[];
  /** List of table creations/deletions */
  tableOps: TableOp[];
  /** Tree of creation, rather than execution */
  creationTree: CreationFlatNode[];
}

export interface TransactionReceiptHeader {
  status: TransactionStatus;
  cpuUsageMicroSeconds: number;
  netUsageWords: number;
}

export interface Action {
  account: string;
  name: string;
  authorization: PermissionLevel[];
  jsonData: string;
  rawData: Uint8Array;
}

export interface ActionTrace {
  receiver: string;
  receipt: ActionReceipt | undefined;
  action: Action | undefined;
  contextFree: boolean;
  elapsed: number;
  console: string;
  transactionId: string;
  blockNum: number;
  producerBlockId: string;
  blockTime: Date | undefined;
  accountRamDeltas: AccountRAMDelta[];
  /**
   * ReturnValue has been added in EOSIO 2.1.x as something that can be returned from the execution
   * of an action.
   *
   * See https://github.com/EOSIO/eos/pull/8327
   */
  rawReturnValue: Uint8Array;
  jsonReturnValue: string;
  exception:
    | Exception
    | undefined;
  /** https://github.com/EOSIO/eos/pull/7108 */
  errorCode: number;
  actionOrdinal: number;
  creatorActionOrdinal: number;
  closestUnnotifiedAncestorActionOrdinal: number;
  executionIndex: number;
  /**
   * Whether this action trace was a successful match, present only when filtering was applied on block. This
   * will be `true` if the Block `filtering_applied` is `true`, if the include CEL filter matched and
   * if the exclude CEL filter did NOT match.
   */
  filteringMatched: boolean;
  /**
   * Whether this action trace was a successful system match, present only when filtering was applied on block.
   * This will be `true` if the Block `filtering_applied` is `true`, if the system actions include CEL filter
   * matched, supersedes any exclude CEL filter.
   */
  filteringMatchedSystemActionFilter: boolean;
}

export interface ActionReceipt {
  receiver: string;
  digest: string;
  globalSequence: number;
  authSequence: AuthSequence[];
  recvSequence: number;
  codeSequence: number;
  abiSequence: number;
}

export interface AuthSequence {
  accountName: string;
  sequence: number;
}

export interface AccountRAMDelta {
  account: string;
  delta: number;
}

export interface AccountDelta {
  account: string;
  delta: number;
}

export interface Extension {
  type: number;
  data: Uint8Array;
}

/**
 * FIXME: this is really just an output of the implicit transactions, isn't it? We don't have
 * other operations here.. do we?  What's the `name` anyway?
 */
export interface TrxOp {
  operation: TrxOp_Operation;
  name: string;
  transactionId: string;
  transaction: SignedTransaction | undefined;
}

export enum TrxOp_Operation {
  OPERATION_UNKNOWN = 0,
  OPERATION_CREATE = 1,
  UNRECOGNIZED = -1,
}

export function trxOp_OperationFromJSON(object: any): TrxOp_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNKNOWN":
      return TrxOp_Operation.OPERATION_UNKNOWN;
    case 1:
    case "OPERATION_CREATE":
      return TrxOp_Operation.OPERATION_CREATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TrxOp_Operation.UNRECOGNIZED;
  }
}

export function trxOp_OperationToJSON(object: TrxOp_Operation): string {
  switch (object) {
    case TrxOp_Operation.OPERATION_UNKNOWN:
      return "OPERATION_UNKNOWN";
    case TrxOp_Operation.OPERATION_CREATE:
      return "OPERATION_CREATE";
    case TrxOp_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DBOp {
  operation: DBOp_Operation;
  actionIndex: number;
  code: string;
  scope: string;
  tableName: string;
  primaryKey: string;
  oldPayer: string;
  newPayer: string;
  oldData: Uint8Array;
  newData: Uint8Array;
  oldDataJson: string;
  newDataJson: string;
}

export enum DBOp_Operation {
  OPERATION_UNKNOWN = 0,
  OPERATION_INSERT = 1,
  OPERATION_UPDATE = 2,
  OPERATION_REMOVE = 3,
  UNRECOGNIZED = -1,
}

export function dBOp_OperationFromJSON(object: any): DBOp_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNKNOWN":
      return DBOp_Operation.OPERATION_UNKNOWN;
    case 1:
    case "OPERATION_INSERT":
      return DBOp_Operation.OPERATION_INSERT;
    case 2:
    case "OPERATION_UPDATE":
      return DBOp_Operation.OPERATION_UPDATE;
    case 3:
    case "OPERATION_REMOVE":
      return DBOp_Operation.OPERATION_REMOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DBOp_Operation.UNRECOGNIZED;
  }
}

export function dBOp_OperationToJSON(object: DBOp_Operation): string {
  switch (object) {
    case DBOp_Operation.OPERATION_UNKNOWN:
      return "OPERATION_UNKNOWN";
    case DBOp_Operation.OPERATION_INSERT:
      return "OPERATION_INSERT";
    case DBOp_Operation.OPERATION_UPDATE:
      return "OPERATION_UPDATE";
    case DBOp_Operation.OPERATION_REMOVE:
      return "OPERATION_REMOVE";
    case DBOp_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RAMOp {
  /**
   * Operation is the legacy operation tag that we used initially. This is replaced
   * by a combination of `Namespce` and `Action`.
   *
   * Deprecated: Use `Namespace` and `Action` instead to determine what the RAM operation represents
   */
  operation: RAMOp_Operation;
  actionIndex: number;
  payer: string;
  delta: number;
  usage: number;
  /**
   * Namespace representing the category the RAM operation belong to, like
   * account, table_row, table, etc.
   *
   * This coupled with `action` replaces the `operation` field.
   */
  namespace: RAMOp_Namespace;
  /**
   * Namespace representing the action the RAM operation did, like
   * add, delete or remove an object.
   *
   * This coupled with `action` replaces the `operation` field.
   */
  action: RAMOp_Action;
  /**
   * UniqueKey gives a unique key to the operation, this unique key is opaque,
   * does not necessarly represents anything and should uniquely represents the
   * RAM Operation within a given timeframe of block (a key should never overlap
   * any other keys (per namespace), on any blocks span).
   */
  uniqueKey: string;
}

export enum RAMOp_Operation {
  OPERATION_UNKNOWN = 0,
  OPERATION_CREATE_TABLE = 1,
  OPERATION_DEFERRED_TRX_ADD = 2,
  OPERATION_DEFERRED_TRX_CANCEL = 3,
  OPERATION_DEFERRED_TRX_PUSHED = 4,
  OPERATION_DEFERRED_TRX_RAM_CORRECTION = 5,
  OPERATION_DEFERRED_TRX_REMOVED = 6,
  OPERATION_DELETEAUTH = 7,
  OPERATION_LINKAUTH = 8,
  OPERATION_NEWACCOUNT = 9,
  OPERATION_PRIMARY_INDEX_ADD = 10,
  OPERATION_PRIMARY_INDEX_REMOVE = 11,
  OPERATION_PRIMARY_INDEX_UPDATE = 12,
  OPERATION_PRIMARY_INDEX_UPDATE_ADD_NEW_PAYER = 13,
  OPERATION_PRIMARY_INDEX_UPDATE_REMOVE_OLD_PAYER = 14,
  OPERATION_REMOVE_TABLE = 15,
  OPERATION_SECONDARY_INDEX_ADD = 16,
  OPERATION_SECONDARY_INDEX_REMOVE = 17,
  OPERATION_SECONDARY_INDEX_UPDATE_ADD_NEW_PAYER = 18,
  OPERATION_SECONDARY_INDEX_UPDATE_REMOVE_OLD_PAYER = 19,
  OPERATION_SETABI = 20,
  OPERATION_SETCODE = 21,
  OPERATION_UNLINKAUTH = 22,
  OPERATION_UPDATEAUTH_CREATE = 23,
  OPERATION_UPDATEAUTH_UPDATE = 24,
  /**
   * OPERATION_DEPRECATED - For newer RAM Ops that are registered by Deep Mind, their `Operation` value will be
   * Deprecated until we remove the operation completely. Use instead the `Namespace`
   * and `Action` fields to take a decision about what the RAM operation is doing.
   */
  OPERATION_DEPRECATED = 25,
  UNRECOGNIZED = -1,
}

export function rAMOp_OperationFromJSON(object: any): RAMOp_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNKNOWN":
      return RAMOp_Operation.OPERATION_UNKNOWN;
    case 1:
    case "OPERATION_CREATE_TABLE":
      return RAMOp_Operation.OPERATION_CREATE_TABLE;
    case 2:
    case "OPERATION_DEFERRED_TRX_ADD":
      return RAMOp_Operation.OPERATION_DEFERRED_TRX_ADD;
    case 3:
    case "OPERATION_DEFERRED_TRX_CANCEL":
      return RAMOp_Operation.OPERATION_DEFERRED_TRX_CANCEL;
    case 4:
    case "OPERATION_DEFERRED_TRX_PUSHED":
      return RAMOp_Operation.OPERATION_DEFERRED_TRX_PUSHED;
    case 5:
    case "OPERATION_DEFERRED_TRX_RAM_CORRECTION":
      return RAMOp_Operation.OPERATION_DEFERRED_TRX_RAM_CORRECTION;
    case 6:
    case "OPERATION_DEFERRED_TRX_REMOVED":
      return RAMOp_Operation.OPERATION_DEFERRED_TRX_REMOVED;
    case 7:
    case "OPERATION_DELETEAUTH":
      return RAMOp_Operation.OPERATION_DELETEAUTH;
    case 8:
    case "OPERATION_LINKAUTH":
      return RAMOp_Operation.OPERATION_LINKAUTH;
    case 9:
    case "OPERATION_NEWACCOUNT":
      return RAMOp_Operation.OPERATION_NEWACCOUNT;
    case 10:
    case "OPERATION_PRIMARY_INDEX_ADD":
      return RAMOp_Operation.OPERATION_PRIMARY_INDEX_ADD;
    case 11:
    case "OPERATION_PRIMARY_INDEX_REMOVE":
      return RAMOp_Operation.OPERATION_PRIMARY_INDEX_REMOVE;
    case 12:
    case "OPERATION_PRIMARY_INDEX_UPDATE":
      return RAMOp_Operation.OPERATION_PRIMARY_INDEX_UPDATE;
    case 13:
    case "OPERATION_PRIMARY_INDEX_UPDATE_ADD_NEW_PAYER":
      return RAMOp_Operation.OPERATION_PRIMARY_INDEX_UPDATE_ADD_NEW_PAYER;
    case 14:
    case "OPERATION_PRIMARY_INDEX_UPDATE_REMOVE_OLD_PAYER":
      return RAMOp_Operation.OPERATION_PRIMARY_INDEX_UPDATE_REMOVE_OLD_PAYER;
    case 15:
    case "OPERATION_REMOVE_TABLE":
      return RAMOp_Operation.OPERATION_REMOVE_TABLE;
    case 16:
    case "OPERATION_SECONDARY_INDEX_ADD":
      return RAMOp_Operation.OPERATION_SECONDARY_INDEX_ADD;
    case 17:
    case "OPERATION_SECONDARY_INDEX_REMOVE":
      return RAMOp_Operation.OPERATION_SECONDARY_INDEX_REMOVE;
    case 18:
    case "OPERATION_SECONDARY_INDEX_UPDATE_ADD_NEW_PAYER":
      return RAMOp_Operation.OPERATION_SECONDARY_INDEX_UPDATE_ADD_NEW_PAYER;
    case 19:
    case "OPERATION_SECONDARY_INDEX_UPDATE_REMOVE_OLD_PAYER":
      return RAMOp_Operation.OPERATION_SECONDARY_INDEX_UPDATE_REMOVE_OLD_PAYER;
    case 20:
    case "OPERATION_SETABI":
      return RAMOp_Operation.OPERATION_SETABI;
    case 21:
    case "OPERATION_SETCODE":
      return RAMOp_Operation.OPERATION_SETCODE;
    case 22:
    case "OPERATION_UNLINKAUTH":
      return RAMOp_Operation.OPERATION_UNLINKAUTH;
    case 23:
    case "OPERATION_UPDATEAUTH_CREATE":
      return RAMOp_Operation.OPERATION_UPDATEAUTH_CREATE;
    case 24:
    case "OPERATION_UPDATEAUTH_UPDATE":
      return RAMOp_Operation.OPERATION_UPDATEAUTH_UPDATE;
    case 25:
    case "OPERATION_DEPRECATED":
      return RAMOp_Operation.OPERATION_DEPRECATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RAMOp_Operation.UNRECOGNIZED;
  }
}

export function rAMOp_OperationToJSON(object: RAMOp_Operation): string {
  switch (object) {
    case RAMOp_Operation.OPERATION_UNKNOWN:
      return "OPERATION_UNKNOWN";
    case RAMOp_Operation.OPERATION_CREATE_TABLE:
      return "OPERATION_CREATE_TABLE";
    case RAMOp_Operation.OPERATION_DEFERRED_TRX_ADD:
      return "OPERATION_DEFERRED_TRX_ADD";
    case RAMOp_Operation.OPERATION_DEFERRED_TRX_CANCEL:
      return "OPERATION_DEFERRED_TRX_CANCEL";
    case RAMOp_Operation.OPERATION_DEFERRED_TRX_PUSHED:
      return "OPERATION_DEFERRED_TRX_PUSHED";
    case RAMOp_Operation.OPERATION_DEFERRED_TRX_RAM_CORRECTION:
      return "OPERATION_DEFERRED_TRX_RAM_CORRECTION";
    case RAMOp_Operation.OPERATION_DEFERRED_TRX_REMOVED:
      return "OPERATION_DEFERRED_TRX_REMOVED";
    case RAMOp_Operation.OPERATION_DELETEAUTH:
      return "OPERATION_DELETEAUTH";
    case RAMOp_Operation.OPERATION_LINKAUTH:
      return "OPERATION_LINKAUTH";
    case RAMOp_Operation.OPERATION_NEWACCOUNT:
      return "OPERATION_NEWACCOUNT";
    case RAMOp_Operation.OPERATION_PRIMARY_INDEX_ADD:
      return "OPERATION_PRIMARY_INDEX_ADD";
    case RAMOp_Operation.OPERATION_PRIMARY_INDEX_REMOVE:
      return "OPERATION_PRIMARY_INDEX_REMOVE";
    case RAMOp_Operation.OPERATION_PRIMARY_INDEX_UPDATE:
      return "OPERATION_PRIMARY_INDEX_UPDATE";
    case RAMOp_Operation.OPERATION_PRIMARY_INDEX_UPDATE_ADD_NEW_PAYER:
      return "OPERATION_PRIMARY_INDEX_UPDATE_ADD_NEW_PAYER";
    case RAMOp_Operation.OPERATION_PRIMARY_INDEX_UPDATE_REMOVE_OLD_PAYER:
      return "OPERATION_PRIMARY_INDEX_UPDATE_REMOVE_OLD_PAYER";
    case RAMOp_Operation.OPERATION_REMOVE_TABLE:
      return "OPERATION_REMOVE_TABLE";
    case RAMOp_Operation.OPERATION_SECONDARY_INDEX_ADD:
      return "OPERATION_SECONDARY_INDEX_ADD";
    case RAMOp_Operation.OPERATION_SECONDARY_INDEX_REMOVE:
      return "OPERATION_SECONDARY_INDEX_REMOVE";
    case RAMOp_Operation.OPERATION_SECONDARY_INDEX_UPDATE_ADD_NEW_PAYER:
      return "OPERATION_SECONDARY_INDEX_UPDATE_ADD_NEW_PAYER";
    case RAMOp_Operation.OPERATION_SECONDARY_INDEX_UPDATE_REMOVE_OLD_PAYER:
      return "OPERATION_SECONDARY_INDEX_UPDATE_REMOVE_OLD_PAYER";
    case RAMOp_Operation.OPERATION_SETABI:
      return "OPERATION_SETABI";
    case RAMOp_Operation.OPERATION_SETCODE:
      return "OPERATION_SETCODE";
    case RAMOp_Operation.OPERATION_UNLINKAUTH:
      return "OPERATION_UNLINKAUTH";
    case RAMOp_Operation.OPERATION_UPDATEAUTH_CREATE:
      return "OPERATION_UPDATEAUTH_CREATE";
    case RAMOp_Operation.OPERATION_UPDATEAUTH_UPDATE:
      return "OPERATION_UPDATEAUTH_UPDATE";
    case RAMOp_Operation.OPERATION_DEPRECATED:
      return "OPERATION_DEPRECATED";
    case RAMOp_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RAMOp_Namespace {
  NAMESPACE_UNKNOWN = 0,
  NAMESPACE_ABI = 1,
  NAMESPACE_ACCOUNT = 2,
  NAMESPACE_AUTH = 3,
  NAMESPACE_AUTH_LINK = 4,
  NAMESPACE_CODE = 5,
  NAMESPACE_DEFERRED_TRX = 6,
  NAMESPACE_SECONDARY_INDEX = 7,
  NAMESPACE_TABLE = 8,
  NAMESPACE_TABLE_ROW = 9,
  UNRECOGNIZED = -1,
}

export function rAMOp_NamespaceFromJSON(object: any): RAMOp_Namespace {
  switch (object) {
    case 0:
    case "NAMESPACE_UNKNOWN":
      return RAMOp_Namespace.NAMESPACE_UNKNOWN;
    case 1:
    case "NAMESPACE_ABI":
      return RAMOp_Namespace.NAMESPACE_ABI;
    case 2:
    case "NAMESPACE_ACCOUNT":
      return RAMOp_Namespace.NAMESPACE_ACCOUNT;
    case 3:
    case "NAMESPACE_AUTH":
      return RAMOp_Namespace.NAMESPACE_AUTH;
    case 4:
    case "NAMESPACE_AUTH_LINK":
      return RAMOp_Namespace.NAMESPACE_AUTH_LINK;
    case 5:
    case "NAMESPACE_CODE":
      return RAMOp_Namespace.NAMESPACE_CODE;
    case 6:
    case "NAMESPACE_DEFERRED_TRX":
      return RAMOp_Namespace.NAMESPACE_DEFERRED_TRX;
    case 7:
    case "NAMESPACE_SECONDARY_INDEX":
      return RAMOp_Namespace.NAMESPACE_SECONDARY_INDEX;
    case 8:
    case "NAMESPACE_TABLE":
      return RAMOp_Namespace.NAMESPACE_TABLE;
    case 9:
    case "NAMESPACE_TABLE_ROW":
      return RAMOp_Namespace.NAMESPACE_TABLE_ROW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RAMOp_Namespace.UNRECOGNIZED;
  }
}

export function rAMOp_NamespaceToJSON(object: RAMOp_Namespace): string {
  switch (object) {
    case RAMOp_Namespace.NAMESPACE_UNKNOWN:
      return "NAMESPACE_UNKNOWN";
    case RAMOp_Namespace.NAMESPACE_ABI:
      return "NAMESPACE_ABI";
    case RAMOp_Namespace.NAMESPACE_ACCOUNT:
      return "NAMESPACE_ACCOUNT";
    case RAMOp_Namespace.NAMESPACE_AUTH:
      return "NAMESPACE_AUTH";
    case RAMOp_Namespace.NAMESPACE_AUTH_LINK:
      return "NAMESPACE_AUTH_LINK";
    case RAMOp_Namespace.NAMESPACE_CODE:
      return "NAMESPACE_CODE";
    case RAMOp_Namespace.NAMESPACE_DEFERRED_TRX:
      return "NAMESPACE_DEFERRED_TRX";
    case RAMOp_Namespace.NAMESPACE_SECONDARY_INDEX:
      return "NAMESPACE_SECONDARY_INDEX";
    case RAMOp_Namespace.NAMESPACE_TABLE:
      return "NAMESPACE_TABLE";
    case RAMOp_Namespace.NAMESPACE_TABLE_ROW:
      return "NAMESPACE_TABLE_ROW";
    case RAMOp_Namespace.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RAMOp_Action {
  ACTION_UNKNOWN = 0,
  ACTION_ADD = 1,
  ACTION_CANCEL = 2,
  ACTION_CORRECTION = 3,
  ACTION_PUSH = 4,
  ACTION_REMOVE = 5,
  ACTION_UPDATE = 6,
  UNRECOGNIZED = -1,
}

export function rAMOp_ActionFromJSON(object: any): RAMOp_Action {
  switch (object) {
    case 0:
    case "ACTION_UNKNOWN":
      return RAMOp_Action.ACTION_UNKNOWN;
    case 1:
    case "ACTION_ADD":
      return RAMOp_Action.ACTION_ADD;
    case 2:
    case "ACTION_CANCEL":
      return RAMOp_Action.ACTION_CANCEL;
    case 3:
    case "ACTION_CORRECTION":
      return RAMOp_Action.ACTION_CORRECTION;
    case 4:
    case "ACTION_PUSH":
      return RAMOp_Action.ACTION_PUSH;
    case 5:
    case "ACTION_REMOVE":
      return RAMOp_Action.ACTION_REMOVE;
    case 6:
    case "ACTION_UPDATE":
      return RAMOp_Action.ACTION_UPDATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RAMOp_Action.UNRECOGNIZED;
  }
}

export function rAMOp_ActionToJSON(object: RAMOp_Action): string {
  switch (object) {
    case RAMOp_Action.ACTION_UNKNOWN:
      return "ACTION_UNKNOWN";
    case RAMOp_Action.ACTION_ADD:
      return "ACTION_ADD";
    case RAMOp_Action.ACTION_CANCEL:
      return "ACTION_CANCEL";
    case RAMOp_Action.ACTION_CORRECTION:
      return "ACTION_CORRECTION";
    case RAMOp_Action.ACTION_PUSH:
      return "ACTION_PUSH";
    case RAMOp_Action.ACTION_REMOVE:
      return "ACTION_REMOVE";
    case RAMOp_Action.ACTION_UPDATE:
      return "ACTION_UPDATE";
    case RAMOp_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RAMCorrectionOp {
  correctionId: string;
  uniqueKey: string;
  payer: string;
  delta: number;
}

export interface TableOp {
  operation: TableOp_Operation;
  actionIndex: number;
  payer: string;
  code: string;
  scope: string;
  tableName: string;
}

export enum TableOp_Operation {
  OPERATION_UNKNOWN = 0,
  OPERATION_INSERT = 1,
  OPERATION_REMOVE = 2,
  UNRECOGNIZED = -1,
}

export function tableOp_OperationFromJSON(object: any): TableOp_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNKNOWN":
      return TableOp_Operation.OPERATION_UNKNOWN;
    case 1:
    case "OPERATION_INSERT":
      return TableOp_Operation.OPERATION_INSERT;
    case 2:
    case "OPERATION_REMOVE":
      return TableOp_Operation.OPERATION_REMOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TableOp_Operation.UNRECOGNIZED;
  }
}

export function tableOp_OperationToJSON(object: TableOp_Operation): string {
  switch (object) {
    case TableOp_Operation.OPERATION_UNKNOWN:
      return "OPERATION_UNKNOWN";
    case TableOp_Operation.OPERATION_INSERT:
      return "OPERATION_INSERT";
    case TableOp_Operation.OPERATION_REMOVE:
      return "OPERATION_REMOVE";
    case TableOp_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DTrxOp {
  operation: DTrxOp_Operation;
  actionIndex: number;
  sender: string;
  senderId: string;
  payer: string;
  publishedAt: string;
  delayUntil: string;
  expirationAt: string;
  transactionId: string;
  transaction: SignedTransaction | undefined;
}

export enum DTrxOp_Operation {
  OPERATION_UNKNOWN = 0,
  OPERATION_CREATE = 1,
  OPERATION_PUSH_CREATE = 2,
  OPERATION_FAILED = 3,
  OPERATION_CANCEL = 4,
  OPERATION_MODIFY_CANCEL = 5,
  OPERATION_MODIFY_CREATE = 6,
  UNRECOGNIZED = -1,
}

export function dTrxOp_OperationFromJSON(object: any): DTrxOp_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNKNOWN":
      return DTrxOp_Operation.OPERATION_UNKNOWN;
    case 1:
    case "OPERATION_CREATE":
      return DTrxOp_Operation.OPERATION_CREATE;
    case 2:
    case "OPERATION_PUSH_CREATE":
      return DTrxOp_Operation.OPERATION_PUSH_CREATE;
    case 3:
    case "OPERATION_FAILED":
      return DTrxOp_Operation.OPERATION_FAILED;
    case 4:
    case "OPERATION_CANCEL":
      return DTrxOp_Operation.OPERATION_CANCEL;
    case 5:
    case "OPERATION_MODIFY_CANCEL":
      return DTrxOp_Operation.OPERATION_MODIFY_CANCEL;
    case 6:
    case "OPERATION_MODIFY_CREATE":
      return DTrxOp_Operation.OPERATION_MODIFY_CREATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DTrxOp_Operation.UNRECOGNIZED;
  }
}

export function dTrxOp_OperationToJSON(object: DTrxOp_Operation): string {
  switch (object) {
    case DTrxOp_Operation.OPERATION_UNKNOWN:
      return "OPERATION_UNKNOWN";
    case DTrxOp_Operation.OPERATION_CREATE:
      return "OPERATION_CREATE";
    case DTrxOp_Operation.OPERATION_PUSH_CREATE:
      return "OPERATION_PUSH_CREATE";
    case DTrxOp_Operation.OPERATION_FAILED:
      return "OPERATION_FAILED";
    case DTrxOp_Operation.OPERATION_CANCEL:
      return "OPERATION_CANCEL";
    case DTrxOp_Operation.OPERATION_MODIFY_CANCEL:
      return "OPERATION_MODIFY_CANCEL";
    case DTrxOp_Operation.OPERATION_MODIFY_CREATE:
      return "OPERATION_MODIFY_CREATE";
    case DTrxOp_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ExtDTrxOp {
  sourceTransactionId: string;
  blockNum: number;
  blockId: string;
  blockTime: Date | undefined;
  dtrxOp: DTrxOp | undefined;
}

export interface FeatureOp {
  kind: string;
  actionIndex: number;
  featureDigest: string;
  feature: Feature | undefined;
}

export enum FeatureOp_Kind {
  KIND_UNKNOWN = 0,
  KIND_PRE_ACTIVATE = 1,
  KIND_ACTIVATE = 2,
  UNRECOGNIZED = -1,
}

export function featureOp_KindFromJSON(object: any): FeatureOp_Kind {
  switch (object) {
    case 0:
    case "KIND_UNKNOWN":
      return FeatureOp_Kind.KIND_UNKNOWN;
    case 1:
    case "KIND_PRE_ACTIVATE":
      return FeatureOp_Kind.KIND_PRE_ACTIVATE;
    case 2:
    case "KIND_ACTIVATE":
      return FeatureOp_Kind.KIND_ACTIVATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeatureOp_Kind.UNRECOGNIZED;
  }
}

export function featureOp_KindToJSON(object: FeatureOp_Kind): string {
  switch (object) {
    case FeatureOp_Kind.KIND_UNKNOWN:
      return "KIND_UNKNOWN";
    case FeatureOp_Kind.KIND_PRE_ACTIVATE:
      return "KIND_PRE_ACTIVATE";
    case FeatureOp_Kind.KIND_ACTIVATE:
      return "KIND_ACTIVATE";
    case FeatureOp_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreationFlatNode {
  creatorActionIndex: number;
  executionActionIndex: number;
}

export interface PermOp {
  operation: PermOp_Operation;
  actionIndex: number;
  oldPerm: PermissionObject | undefined;
  newPerm: PermissionObject | undefined;
}

export enum PermOp_Operation {
  OPERATION_UNKNOWN = 0,
  OPERATION_INSERT = 1,
  OPERATION_UPDATE = 2,
  OPERATION_REMOVE = 3,
  UNRECOGNIZED = -1,
}

export function permOp_OperationFromJSON(object: any): PermOp_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNKNOWN":
      return PermOp_Operation.OPERATION_UNKNOWN;
    case 1:
    case "OPERATION_INSERT":
      return PermOp_Operation.OPERATION_INSERT;
    case 2:
    case "OPERATION_UPDATE":
      return PermOp_Operation.OPERATION_UPDATE;
    case 3:
    case "OPERATION_REMOVE":
      return PermOp_Operation.OPERATION_REMOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PermOp_Operation.UNRECOGNIZED;
  }
}

export function permOp_OperationToJSON(object: PermOp_Operation): string {
  switch (object) {
    case PermOp_Operation.OPERATION_UNKNOWN:
      return "OPERATION_UNKNOWN";
    case PermOp_Operation.OPERATION_INSERT:
      return "OPERATION_INSERT";
    case PermOp_Operation.OPERATION_UPDATE:
      return "OPERATION_UPDATE";
    case PermOp_Operation.OPERATION_REMOVE:
      return "OPERATION_REMOVE";
    case PermOp_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PermissionObject {
  /** Id represents the EOSIO internal id of this permission object. */
  id: number;
  /** ParentId represents the EOSIO internal id of the parent's of this permission object. */
  parentId: number;
  /** Owner is the account for which this permission was set */
  owner: string;
  /** Name is the permission's name this permission object is known as. */
  name: string;
  lastUpdated: Date | undefined;
  authority: Authority | undefined;
}

export interface Permission {
  name: string;
  parent: string;
  requiredAuth: Authority | undefined;
}

export interface Authority {
  threshold: number;
  keys: KeyWeight[];
  accounts: PermissionLevelWeight[];
  waits: WaitWeight[];
}

export interface KeyWeight {
  publicKey: string;
  weight: number;
}

export interface PermissionLevel {
  actor: string;
  permission: string;
}

export interface PermissionLevelWeight {
  permission: PermissionLevel | undefined;
  weight: number;
}

export interface WaitWeight {
  waitSec: number;
  weight: number;
}

export interface RlimitOp {
  operation: RlimitOp_Operation;
  state?: RlimitState | undefined;
  config?: RlimitConfig | undefined;
  accountLimits?: RlimitAccountLimits | undefined;
  accountUsage?: RlimitAccountUsage | undefined;
}

export enum RlimitOp_Operation {
  OPERATION_UNKNOWN = 0,
  OPERATION_INSERT = 1,
  OPERATION_UPDATE = 2,
  UNRECOGNIZED = -1,
}

export function rlimitOp_OperationFromJSON(object: any): RlimitOp_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNKNOWN":
      return RlimitOp_Operation.OPERATION_UNKNOWN;
    case 1:
    case "OPERATION_INSERT":
      return RlimitOp_Operation.OPERATION_INSERT;
    case 2:
    case "OPERATION_UPDATE":
      return RlimitOp_Operation.OPERATION_UPDATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RlimitOp_Operation.UNRECOGNIZED;
  }
}

export function rlimitOp_OperationToJSON(object: RlimitOp_Operation): string {
  switch (object) {
    case RlimitOp_Operation.OPERATION_UNKNOWN:
      return "OPERATION_UNKNOWN";
    case RlimitOp_Operation.OPERATION_INSERT:
      return "OPERATION_INSERT";
    case RlimitOp_Operation.OPERATION_UPDATE:
      return "OPERATION_UPDATE";
    case RlimitOp_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RlimitState {
  averageBlockNetUsage: UsageAccumulator | undefined;
  averageBlockCpuUsage: UsageAccumulator | undefined;
  pendingNetUsage: number;
  pendingCpuUsage: number;
  totalNetWeight: number;
  totalCpuWeight: number;
  totalRamBytes: number;
  virtualNetLimit: number;
  virtualCpuLimit: number;
}

export interface RlimitConfig {
  cpuLimitParameters: ElasticLimitParameters | undefined;
  netLimitParameters: ElasticLimitParameters | undefined;
  accountCpuUsageAverageWindow: number;
  accountNetUsageAverageWindow: number;
}

export interface RlimitAccountLimits {
  owner: string;
  pending: boolean;
  netWeight: number;
  cpuWeight: number;
  ramBytes: number;
}

export interface RlimitAccountUsage {
  owner: string;
  netUsage: UsageAccumulator | undefined;
  cpuUsage: UsageAccumulator | undefined;
  ramUsage: number;
}

export interface UsageAccumulator {
  lastOrdinal: number;
  valueEx: number;
  consumed: number;
}

export interface ElasticLimitParameters {
  target: number;
  max: number;
  periods: number;
  maxMultiplier: number;
  contractRate: Ratio | undefined;
  expandRate: Ratio | undefined;
}

export interface Ratio {
  numerator: number;
  denominator: number;
}

export interface Exception {
  code: number;
  name: string;
  message: string;
  stack: Exception_LogMessage[];
}

export interface Exception_LogMessage {
  context: Exception_LogContext | undefined;
  format: string;
  /**
   * This is actually a Pair<string, any> in C++ which get serialized usually
   * as a JSON object. However, it seems some string sequences could be
   * invalid UTF-8 characters. As such, we decided to use a bytes array. Can
   * be interpreted as a UTF-8 string containing JSON, just be ready to
   * handle UTF-8 errors if they arise.
   */
  data: Uint8Array;
}

export interface Exception_LogContext {
  level: string;
  file: string;
  line: number;
  method: string;
  hostname: string;
  threadName: string;
  timestamp: Date | undefined;
  context: Exception_LogContext | undefined;
}

export interface Feature {
  featureDigest: string;
  subjectiveRestrictions: SubjectiveRestrictions | undefined;
  descriptionDigest: string;
  dependencies: string[];
  protocolFeatureType: string;
  specification: Specification[];
}

export interface SubjectiveRestrictions {
  enabled: boolean;
  preactivationRequired: boolean;
  earliestAllowedActivationTime: string;
}

export interface Specification {
  name: string;
  value: string;
}

/** AccountCreation represents the time and place where an account was created on an EOSIO chain. The block referenced is expected to be irreversible. */
export interface AccountCreationRef {
  /** Account being created */
  account: string;
  /** Account that created the `account` */
  creator: string;
  /** At which block number this happened */
  blockNum: number;
  /** At which block ID this happened */
  blockId: string;
  blockTime: Date | undefined;
  transactionId: string;
}

/**
 * HeaderOnlyBlock is used to optimally unpack the [Block] structure (note the
 * corresponding message number for the `header` field) while consuming less
 * memory, when only the `header` is desired.
 *
 * WARN: this is a client-side optimization pattern and should be moved in the
 * consuming code.
 */
export interface HeaderOnlyBlock {
  /** id is the block's hash. */
  id: string;
  /** Number is the block's height at which this block was mined. */
  number: number;
  /**
   * Header contain's the block's header information like its parent hash, the merkel root hash
   * and all other information the form a block.
   */
  header:
    | BlockHeader
    | undefined;
  /**
   * A blockroot Merkle tree is a data structure that uses hash functions to organize and
   * verify the integrity of data blocks in a blockchain.
   * Each leaf node contains a hash of a data block, while each non-leaf node contains the hash of its child nodes.
   * The root node contains a single hash that represents all the data in the tree,
   * allowing for efficient verification of data integrity by only checking the root hash.
   */
  blockrootMerkle: BlockRootMerkle | undefined;
}

export interface TransactionTraceWithBlockRef {
  trace: TransactionTrace | undefined;
  blockRef: BlockRef | undefined;
}

export interface BlockRef {
  hash: Uint8Array;
  number: number;
}

function createBaseActionTraces(): ActionTraces {
  return { actionTraces: [] };
}

export const ActionTraces: MessageFns<ActionTraces> = {
  encode(message: ActionTraces, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actionTraces) {
      ActionTrace.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionTraces {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionTraces();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actionTraces.push(ActionTrace.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionTraces {
    return {
      actionTraces: globalThis.Array.isArray(object?.actionTraces)
        ? object.actionTraces.map((e: any) => ActionTrace.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ActionTraces): unknown {
    const obj: any = {};
    if (message.actionTraces?.length) {
      obj.actionTraces = message.actionTraces.map((e) => ActionTrace.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ActionTraces>): ActionTraces {
    return ActionTraces.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionTraces>): ActionTraces {
    const message = createBaseActionTraces();
    message.actionTraces = object.actionTraces?.map((e) => ActionTrace.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionTraces(): TransactionTraces {
  return { transactionTraces: [] };
}

export const TransactionTraces: MessageFns<TransactionTraces> = {
  encode(message: TransactionTraces, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactionTraces) {
      TransactionTrace.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionTraces {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionTraces();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionTraces.push(TransactionTrace.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionTraces {
    return {
      transactionTraces: globalThis.Array.isArray(object?.transactionTraces)
        ? object.transactionTraces.map((e: any) => TransactionTrace.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionTraces): unknown {
    const obj: any = {};
    if (message.transactionTraces?.length) {
      obj.transactionTraces = message.transactionTraces.map((e) => TransactionTrace.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionTraces>): TransactionTraces {
    return TransactionTraces.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionTraces>): TransactionTraces {
    const message = createBaseTransactionTraces();
    message.transactionTraces = object.transactionTraces?.map((e) => TransactionTrace.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDBOps(): DBOps {
  return { dbOps: [] };
}

export const DBOps: MessageFns<DBOps> = {
  encode(message: DBOps, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dbOps) {
      DBOp.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DBOps {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDBOps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dbOps.push(DBOp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DBOps {
    return { dbOps: globalThis.Array.isArray(object?.dbOps) ? object.dbOps.map((e: any) => DBOp.fromJSON(e)) : [] };
  },

  toJSON(message: DBOps): unknown {
    const obj: any = {};
    if (message.dbOps?.length) {
      obj.dbOps = message.dbOps.map((e) => DBOp.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DBOps>): DBOps {
    return DBOps.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DBOps>): DBOps {
    const message = createBaseDBOps();
    message.dbOps = object.dbOps?.map((e) => DBOp.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlock(): Block {
  return {
    id: "",
    number: 0,
    version: 0,
    header: undefined,
    producerSignature: "",
    blockExtensions: [],
    dposProposedIrreversibleBlocknum: 0,
    dposIrreversibleBlocknum: 0,
    blockrootMerkle: undefined,
    producerToLastProduced: [],
    producerToLastImpliedIrb: [],
    confirmCount: [],
    pendingSchedule: undefined,
    activatedProtocolFeatures: undefined,
    validated: false,
    actionMrootSavanna: new Uint8Array(0),
    finalityLib: 0,
    finalityData: undefined,
    proposerPolicy: undefined,
    finalizerPolicy: undefined,
    rlimitOps: [],
    unfilteredTransactions: [],
    filteredTransactions: [],
    unfilteredTransactionCount: 0,
    filteredTransactionCount: 0,
    unfilteredImplicitTransactionOps: [],
    filteredImplicitTransactionOps: [],
    unfilteredTransactionTraces: [],
    filteredTransactionTraces: [],
    unfilteredTransactionTraceCount: 0,
    filteredTransactionTraceCount: 0,
    unfilteredExecutedInputActionCount: 0,
    filteredExecutedInputActionCount: 0,
    unfilteredExecutedTotalActionCount: 0,
    filteredExecutedTotalActionCount: 0,
    blockSigningKey: "",
    activeScheduleV1: undefined,
    validBlockSigningAuthorityV2: undefined,
    activeScheduleV2: undefined,
    filteringApplied: false,
    filteringIncludeFilterExpr: "",
    filteringExcludeFilterExpr: "",
    filteringSystemActionsIncludeFilterExpr: "",
  };
}

export const Block: MessageFns<Block> = {
  encode(message: Block, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.number !== 0) {
      writer.uint32(16).uint32(message.number);
    }
    if (message.version !== 0) {
      writer.uint32(24).uint32(message.version);
    }
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(34).fork()).join();
    }
    if (message.producerSignature !== "") {
      writer.uint32(42).string(message.producerSignature);
    }
    for (const v of message.blockExtensions) {
      Extension.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.dposProposedIrreversibleBlocknum !== 0) {
      writer.uint32(64).uint32(message.dposProposedIrreversibleBlocknum);
    }
    if (message.dposIrreversibleBlocknum !== 0) {
      writer.uint32(72).uint32(message.dposIrreversibleBlocknum);
    }
    if (message.blockrootMerkle !== undefined) {
      BlockRootMerkle.encode(message.blockrootMerkle, writer.uint32(90).fork()).join();
    }
    for (const v of message.producerToLastProduced) {
      ProducerToLastProduced.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.producerToLastImpliedIrb) {
      ProducerToLastImpliedIRB.encode(v!, writer.uint32(106).fork()).join();
    }
    writer.uint32(122).fork();
    for (const v of message.confirmCount) {
      writer.uint32(v);
    }
    writer.join();
    if (message.pendingSchedule !== undefined) {
      PendingProducerSchedule.encode(message.pendingSchedule, writer.uint32(130).fork()).join();
    }
    if (message.activatedProtocolFeatures !== undefined) {
      ActivatedProtocolFeatures.encode(message.activatedProtocolFeatures, writer.uint32(138).fork()).join();
    }
    if (message.validated !== false) {
      writer.uint32(144).bool(message.validated);
    }
    if (message.actionMrootSavanna.length !== 0) {
      writer.uint32(482).bytes(message.actionMrootSavanna);
    }
    if (message.finalityLib !== 0) {
      writer.uint32(488).uint32(message.finalityLib);
    }
    if (message.finalityData !== undefined) {
      FinalityData.encode(message.finalityData, writer.uint32(498).fork()).join();
    }
    if (message.proposerPolicy !== undefined) {
      ProposerPolicy.encode(message.proposerPolicy, writer.uint32(506).fork()).join();
    }
    if (message.finalizerPolicy !== undefined) {
      FinalizerPolicy.encode(message.finalizerPolicy, writer.uint32(514).fork()).join();
    }
    for (const v of message.rlimitOps) {
      RlimitOp.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.unfilteredTransactions) {
      TransactionReceipt.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.filteredTransactions) {
      TransactionReceipt.encode(v!, writer.uint32(378).fork()).join();
    }
    if (message.unfilteredTransactionCount !== 0) {
      writer.uint32(176).uint32(message.unfilteredTransactionCount);
    }
    if (message.filteredTransactionCount !== 0) {
      writer.uint32(384).uint32(message.filteredTransactionCount);
    }
    for (const v of message.unfilteredImplicitTransactionOps) {
      TrxOp.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.filteredImplicitTransactionOps) {
      TrxOp.encode(v!, writer.uint32(394).fork()).join();
    }
    for (const v of message.unfilteredTransactionTraces) {
      TransactionTrace.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.filteredTransactionTraces) {
      TransactionTrace.encode(v!, writer.uint32(370).fork()).join();
    }
    if (message.unfilteredTransactionTraceCount !== 0) {
      writer.uint32(184).uint32(message.unfilteredTransactionTraceCount);
    }
    if (message.filteredTransactionTraceCount !== 0) {
      writer.uint32(344).uint32(message.filteredTransactionTraceCount);
    }
    if (message.unfilteredExecutedInputActionCount !== 0) {
      writer.uint32(192).uint32(message.unfilteredExecutedInputActionCount);
    }
    if (message.filteredExecutedInputActionCount !== 0) {
      writer.uint32(352).uint32(message.filteredExecutedInputActionCount);
    }
    if (message.unfilteredExecutedTotalActionCount !== 0) {
      writer.uint32(200).uint32(message.unfilteredExecutedTotalActionCount);
    }
    if (message.filteredExecutedTotalActionCount !== 0) {
      writer.uint32(360).uint32(message.filteredExecutedTotalActionCount);
    }
    if (message.blockSigningKey !== "") {
      writer.uint32(114).string(message.blockSigningKey);
    }
    if (message.activeScheduleV1 !== undefined) {
      ProducerSchedule.encode(message.activeScheduleV1, writer.uint32(82).fork()).join();
    }
    if (message.validBlockSigningAuthorityV2 !== undefined) {
      BlockSigningAuthority.encode(message.validBlockSigningAuthorityV2, writer.uint32(242).fork()).join();
    }
    if (message.activeScheduleV2 !== undefined) {
      ProducerAuthoritySchedule.encode(message.activeScheduleV2, writer.uint32(250).fork()).join();
    }
    if (message.filteringApplied !== false) {
      writer.uint32(320).bool(message.filteringApplied);
    }
    if (message.filteringIncludeFilterExpr !== "") {
      writer.uint32(330).string(message.filteringIncludeFilterExpr);
    }
    if (message.filteringExcludeFilterExpr !== "") {
      writer.uint32(338).string(message.filteringExcludeFilterExpr);
    }
    if (message.filteringSystemActionsIncludeFilterExpr !== "") {
      writer.uint32(402).string(message.filteringSystemActionsIncludeFilterExpr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Block {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.number = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.producerSignature = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.blockExtensions.push(Extension.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.dposProposedIrreversibleBlocknum = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.dposIrreversibleBlocknum = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.blockrootMerkle = BlockRootMerkle.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.producerToLastProduced.push(ProducerToLastProduced.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.producerToLastImpliedIrb.push(ProducerToLastImpliedIRB.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag === 120) {
            message.confirmCount.push(reader.uint32());

            continue;
          }

          if (tag === 122) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.confirmCount.push(reader.uint32());
            }

            continue;
          }

          break;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.pendingSchedule = PendingProducerSchedule.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.activatedProtocolFeatures = ActivatedProtocolFeatures.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.validated = reader.bool();
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }

          message.actionMrootSavanna = reader.bytes();
          continue;
        case 61:
          if (tag !== 488) {
            break;
          }

          message.finalityLib = reader.uint32();
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }

          message.finalityData = FinalityData.decode(reader, reader.uint32());
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }

          message.proposerPolicy = ProposerPolicy.decode(reader, reader.uint32());
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }

          message.finalizerPolicy = FinalizerPolicy.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.rlimitOps.push(RlimitOp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.unfilteredTransactions.push(TransactionReceipt.decode(reader, reader.uint32()));
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.filteredTransactions.push(TransactionReceipt.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.unfilteredTransactionCount = reader.uint32();
          continue;
        case 48:
          if (tag !== 384) {
            break;
          }

          message.filteredTransactionCount = reader.uint32();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.unfilteredImplicitTransactionOps.push(TrxOp.decode(reader, reader.uint32()));
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.filteredImplicitTransactionOps.push(TrxOp.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.unfilteredTransactionTraces.push(TransactionTrace.decode(reader, reader.uint32()));
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.filteredTransactionTraces.push(TransactionTrace.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.unfilteredTransactionTraceCount = reader.uint32();
          continue;
        case 43:
          if (tag !== 344) {
            break;
          }

          message.filteredTransactionTraceCount = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.unfilteredExecutedInputActionCount = reader.uint32();
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.filteredExecutedInputActionCount = reader.uint32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.unfilteredExecutedTotalActionCount = reader.uint32();
          continue;
        case 45:
          if (tag !== 360) {
            break;
          }

          message.filteredExecutedTotalActionCount = reader.uint32();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.blockSigningKey = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.activeScheduleV1 = ProducerSchedule.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.validBlockSigningAuthorityV2 = BlockSigningAuthority.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.activeScheduleV2 = ProducerAuthoritySchedule.decode(reader, reader.uint32());
          continue;
        case 40:
          if (tag !== 320) {
            break;
          }

          message.filteringApplied = reader.bool();
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.filteringIncludeFilterExpr = reader.string();
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.filteringExcludeFilterExpr = reader.string();
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.filteringSystemActionsIncludeFilterExpr = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      producerSignature: isSet(object.producerSignature) ? globalThis.String(object.producerSignature) : "",
      blockExtensions: globalThis.Array.isArray(object?.blockExtensions)
        ? object.blockExtensions.map((e: any) => Extension.fromJSON(e))
        : [],
      dposProposedIrreversibleBlocknum: isSet(object.dposProposedIrreversibleBlocknum)
        ? globalThis.Number(object.dposProposedIrreversibleBlocknum)
        : 0,
      dposIrreversibleBlocknum: isSet(object.dposIrreversibleBlocknum)
        ? globalThis.Number(object.dposIrreversibleBlocknum)
        : 0,
      blockrootMerkle: isSet(object.blockrootMerkle) ? BlockRootMerkle.fromJSON(object.blockrootMerkle) : undefined,
      producerToLastProduced: globalThis.Array.isArray(object?.producerToLastProduced)
        ? object.producerToLastProduced.map((e: any) => ProducerToLastProduced.fromJSON(e))
        : [],
      producerToLastImpliedIrb: globalThis.Array.isArray(object?.producerToLastImpliedIrb)
        ? object.producerToLastImpliedIrb.map((e: any) => ProducerToLastImpliedIRB.fromJSON(e))
        : [],
      confirmCount: globalThis.Array.isArray(object?.confirmCount)
        ? object.confirmCount.map((e: any) => globalThis.Number(e))
        : [],
      pendingSchedule: isSet(object.pendingSchedule)
        ? PendingProducerSchedule.fromJSON(object.pendingSchedule)
        : undefined,
      activatedProtocolFeatures: isSet(object.activatedProtocolFeatures)
        ? ActivatedProtocolFeatures.fromJSON(object.activatedProtocolFeatures)
        : undefined,
      validated: isSet(object.validated) ? globalThis.Boolean(object.validated) : false,
      actionMrootSavanna: isSet(object.actionMrootSavanna)
        ? bytesFromBase64(object.actionMrootSavanna)
        : new Uint8Array(0),
      finalityLib: isSet(object.finalityLib) ? globalThis.Number(object.finalityLib) : 0,
      finalityData: isSet(object.finalityData) ? FinalityData.fromJSON(object.finalityData) : undefined,
      proposerPolicy: isSet(object.proposerPolicy) ? ProposerPolicy.fromJSON(object.proposerPolicy) : undefined,
      finalizerPolicy: isSet(object.finalizerPolicy) ? FinalizerPolicy.fromJSON(object.finalizerPolicy) : undefined,
      rlimitOps: globalThis.Array.isArray(object?.rlimitOps)
        ? object.rlimitOps.map((e: any) => RlimitOp.fromJSON(e))
        : [],
      unfilteredTransactions: globalThis.Array.isArray(object?.unfilteredTransactions)
        ? object.unfilteredTransactions.map((e: any) => TransactionReceipt.fromJSON(e))
        : [],
      filteredTransactions: globalThis.Array.isArray(object?.filteredTransactions)
        ? object.filteredTransactions.map((e: any) => TransactionReceipt.fromJSON(e))
        : [],
      unfilteredTransactionCount: isSet(object.unfilteredTransactionCount)
        ? globalThis.Number(object.unfilteredTransactionCount)
        : 0,
      filteredTransactionCount: isSet(object.filteredTransactionCount)
        ? globalThis.Number(object.filteredTransactionCount)
        : 0,
      unfilteredImplicitTransactionOps: globalThis.Array.isArray(object?.unfilteredImplicitTransactionOps)
        ? object.unfilteredImplicitTransactionOps.map((e: any) => TrxOp.fromJSON(e))
        : [],
      filteredImplicitTransactionOps: globalThis.Array.isArray(object?.filteredImplicitTransactionOps)
        ? object.filteredImplicitTransactionOps.map((e: any) => TrxOp.fromJSON(e))
        : [],
      unfilteredTransactionTraces: globalThis.Array.isArray(object?.unfilteredTransactionTraces)
        ? object.unfilteredTransactionTraces.map((e: any) => TransactionTrace.fromJSON(e))
        : [],
      filteredTransactionTraces: globalThis.Array.isArray(object?.filteredTransactionTraces)
        ? object.filteredTransactionTraces.map((e: any) => TransactionTrace.fromJSON(e))
        : [],
      unfilteredTransactionTraceCount: isSet(object.unfilteredTransactionTraceCount)
        ? globalThis.Number(object.unfilteredTransactionTraceCount)
        : 0,
      filteredTransactionTraceCount: isSet(object.filteredTransactionTraceCount)
        ? globalThis.Number(object.filteredTransactionTraceCount)
        : 0,
      unfilteredExecutedInputActionCount: isSet(object.unfilteredExecutedInputActionCount)
        ? globalThis.Number(object.unfilteredExecutedInputActionCount)
        : 0,
      filteredExecutedInputActionCount: isSet(object.filteredExecutedInputActionCount)
        ? globalThis.Number(object.filteredExecutedInputActionCount)
        : 0,
      unfilteredExecutedTotalActionCount: isSet(object.unfilteredExecutedTotalActionCount)
        ? globalThis.Number(object.unfilteredExecutedTotalActionCount)
        : 0,
      filteredExecutedTotalActionCount: isSet(object.filteredExecutedTotalActionCount)
        ? globalThis.Number(object.filteredExecutedTotalActionCount)
        : 0,
      blockSigningKey: isSet(object.blockSigningKey) ? globalThis.String(object.blockSigningKey) : "",
      activeScheduleV1: isSet(object.activeScheduleV1) ? ProducerSchedule.fromJSON(object.activeScheduleV1) : undefined,
      validBlockSigningAuthorityV2: isSet(object.validBlockSigningAuthorityV2)
        ? BlockSigningAuthority.fromJSON(object.validBlockSigningAuthorityV2)
        : undefined,
      activeScheduleV2: isSet(object.activeScheduleV2)
        ? ProducerAuthoritySchedule.fromJSON(object.activeScheduleV2)
        : undefined,
      filteringApplied: isSet(object.filteringApplied) ? globalThis.Boolean(object.filteringApplied) : false,
      filteringIncludeFilterExpr: isSet(object.filteringIncludeFilterExpr)
        ? globalThis.String(object.filteringIncludeFilterExpr)
        : "",
      filteringExcludeFilterExpr: isSet(object.filteringExcludeFilterExpr)
        ? globalThis.String(object.filteringExcludeFilterExpr)
        : "",
      filteringSystemActionsIncludeFilterExpr: isSet(object.filteringSystemActionsIncludeFilterExpr)
        ? globalThis.String(object.filteringSystemActionsIncludeFilterExpr)
        : "",
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (message.producerSignature !== "") {
      obj.producerSignature = message.producerSignature;
    }
    if (message.blockExtensions?.length) {
      obj.blockExtensions = message.blockExtensions.map((e) => Extension.toJSON(e));
    }
    if (message.dposProposedIrreversibleBlocknum !== 0) {
      obj.dposProposedIrreversibleBlocknum = Math.round(message.dposProposedIrreversibleBlocknum);
    }
    if (message.dposIrreversibleBlocknum !== 0) {
      obj.dposIrreversibleBlocknum = Math.round(message.dposIrreversibleBlocknum);
    }
    if (message.blockrootMerkle !== undefined) {
      obj.blockrootMerkle = BlockRootMerkle.toJSON(message.blockrootMerkle);
    }
    if (message.producerToLastProduced?.length) {
      obj.producerToLastProduced = message.producerToLastProduced.map((e) => ProducerToLastProduced.toJSON(e));
    }
    if (message.producerToLastImpliedIrb?.length) {
      obj.producerToLastImpliedIrb = message.producerToLastImpliedIrb.map((e) => ProducerToLastImpliedIRB.toJSON(e));
    }
    if (message.confirmCount?.length) {
      obj.confirmCount = message.confirmCount.map((e) => Math.round(e));
    }
    if (message.pendingSchedule !== undefined) {
      obj.pendingSchedule = PendingProducerSchedule.toJSON(message.pendingSchedule);
    }
    if (message.activatedProtocolFeatures !== undefined) {
      obj.activatedProtocolFeatures = ActivatedProtocolFeatures.toJSON(message.activatedProtocolFeatures);
    }
    if (message.validated !== false) {
      obj.validated = message.validated;
    }
    if (message.actionMrootSavanna.length !== 0) {
      obj.actionMrootSavanna = base64FromBytes(message.actionMrootSavanna);
    }
    if (message.finalityLib !== 0) {
      obj.finalityLib = Math.round(message.finalityLib);
    }
    if (message.finalityData !== undefined) {
      obj.finalityData = FinalityData.toJSON(message.finalityData);
    }
    if (message.proposerPolicy !== undefined) {
      obj.proposerPolicy = ProposerPolicy.toJSON(message.proposerPolicy);
    }
    if (message.finalizerPolicy !== undefined) {
      obj.finalizerPolicy = FinalizerPolicy.toJSON(message.finalizerPolicy);
    }
    if (message.rlimitOps?.length) {
      obj.rlimitOps = message.rlimitOps.map((e) => RlimitOp.toJSON(e));
    }
    if (message.unfilteredTransactions?.length) {
      obj.unfilteredTransactions = message.unfilteredTransactions.map((e) => TransactionReceipt.toJSON(e));
    }
    if (message.filteredTransactions?.length) {
      obj.filteredTransactions = message.filteredTransactions.map((e) => TransactionReceipt.toJSON(e));
    }
    if (message.unfilteredTransactionCount !== 0) {
      obj.unfilteredTransactionCount = Math.round(message.unfilteredTransactionCount);
    }
    if (message.filteredTransactionCount !== 0) {
      obj.filteredTransactionCount = Math.round(message.filteredTransactionCount);
    }
    if (message.unfilteredImplicitTransactionOps?.length) {
      obj.unfilteredImplicitTransactionOps = message.unfilteredImplicitTransactionOps.map((e) => TrxOp.toJSON(e));
    }
    if (message.filteredImplicitTransactionOps?.length) {
      obj.filteredImplicitTransactionOps = message.filteredImplicitTransactionOps.map((e) => TrxOp.toJSON(e));
    }
    if (message.unfilteredTransactionTraces?.length) {
      obj.unfilteredTransactionTraces = message.unfilteredTransactionTraces.map((e) => TransactionTrace.toJSON(e));
    }
    if (message.filteredTransactionTraces?.length) {
      obj.filteredTransactionTraces = message.filteredTransactionTraces.map((e) => TransactionTrace.toJSON(e));
    }
    if (message.unfilteredTransactionTraceCount !== 0) {
      obj.unfilteredTransactionTraceCount = Math.round(message.unfilteredTransactionTraceCount);
    }
    if (message.filteredTransactionTraceCount !== 0) {
      obj.filteredTransactionTraceCount = Math.round(message.filteredTransactionTraceCount);
    }
    if (message.unfilteredExecutedInputActionCount !== 0) {
      obj.unfilteredExecutedInputActionCount = Math.round(message.unfilteredExecutedInputActionCount);
    }
    if (message.filteredExecutedInputActionCount !== 0) {
      obj.filteredExecutedInputActionCount = Math.round(message.filteredExecutedInputActionCount);
    }
    if (message.unfilteredExecutedTotalActionCount !== 0) {
      obj.unfilteredExecutedTotalActionCount = Math.round(message.unfilteredExecutedTotalActionCount);
    }
    if (message.filteredExecutedTotalActionCount !== 0) {
      obj.filteredExecutedTotalActionCount = Math.round(message.filteredExecutedTotalActionCount);
    }
    if (message.blockSigningKey !== "") {
      obj.blockSigningKey = message.blockSigningKey;
    }
    if (message.activeScheduleV1 !== undefined) {
      obj.activeScheduleV1 = ProducerSchedule.toJSON(message.activeScheduleV1);
    }
    if (message.validBlockSigningAuthorityV2 !== undefined) {
      obj.validBlockSigningAuthorityV2 = BlockSigningAuthority.toJSON(message.validBlockSigningAuthorityV2);
    }
    if (message.activeScheduleV2 !== undefined) {
      obj.activeScheduleV2 = ProducerAuthoritySchedule.toJSON(message.activeScheduleV2);
    }
    if (message.filteringApplied !== false) {
      obj.filteringApplied = message.filteringApplied;
    }
    if (message.filteringIncludeFilterExpr !== "") {
      obj.filteringIncludeFilterExpr = message.filteringIncludeFilterExpr;
    }
    if (message.filteringExcludeFilterExpr !== "") {
      obj.filteringExcludeFilterExpr = message.filteringExcludeFilterExpr;
    }
    if (message.filteringSystemActionsIncludeFilterExpr !== "") {
      obj.filteringSystemActionsIncludeFilterExpr = message.filteringSystemActionsIncludeFilterExpr;
    }
    return obj;
  },

  create(base?: DeepPartial<Block>): Block {
    return Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Block>): Block {
    const message = createBaseBlock();
    message.id = object.id ?? "";
    message.number = object.number ?? 0;
    message.version = object.version ?? 0;
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.producerSignature = object.producerSignature ?? "";
    message.blockExtensions = object.blockExtensions?.map((e) => Extension.fromPartial(e)) || [];
    message.dposProposedIrreversibleBlocknum = object.dposProposedIrreversibleBlocknum ?? 0;
    message.dposIrreversibleBlocknum = object.dposIrreversibleBlocknum ?? 0;
    message.blockrootMerkle = (object.blockrootMerkle !== undefined && object.blockrootMerkle !== null)
      ? BlockRootMerkle.fromPartial(object.blockrootMerkle)
      : undefined;
    message.producerToLastProduced = object.producerToLastProduced?.map((e) => ProducerToLastProduced.fromPartial(e)) ||
      [];
    message.producerToLastImpliedIrb =
      object.producerToLastImpliedIrb?.map((e) => ProducerToLastImpliedIRB.fromPartial(e)) || [];
    message.confirmCount = object.confirmCount?.map((e) => e) || [];
    message.pendingSchedule = (object.pendingSchedule !== undefined && object.pendingSchedule !== null)
      ? PendingProducerSchedule.fromPartial(object.pendingSchedule)
      : undefined;
    message.activatedProtocolFeatures =
      (object.activatedProtocolFeatures !== undefined && object.activatedProtocolFeatures !== null)
        ? ActivatedProtocolFeatures.fromPartial(object.activatedProtocolFeatures)
        : undefined;
    message.validated = object.validated ?? false;
    message.actionMrootSavanna = object.actionMrootSavanna ?? new Uint8Array(0);
    message.finalityLib = object.finalityLib ?? 0;
    message.finalityData = (object.finalityData !== undefined && object.finalityData !== null)
      ? FinalityData.fromPartial(object.finalityData)
      : undefined;
    message.proposerPolicy = (object.proposerPolicy !== undefined && object.proposerPolicy !== null)
      ? ProposerPolicy.fromPartial(object.proposerPolicy)
      : undefined;
    message.finalizerPolicy = (object.finalizerPolicy !== undefined && object.finalizerPolicy !== null)
      ? FinalizerPolicy.fromPartial(object.finalizerPolicy)
      : undefined;
    message.rlimitOps = object.rlimitOps?.map((e) => RlimitOp.fromPartial(e)) || [];
    message.unfilteredTransactions = object.unfilteredTransactions?.map((e) => TransactionReceipt.fromPartial(e)) || [];
    message.filteredTransactions = object.filteredTransactions?.map((e) => TransactionReceipt.fromPartial(e)) || [];
    message.unfilteredTransactionCount = object.unfilteredTransactionCount ?? 0;
    message.filteredTransactionCount = object.filteredTransactionCount ?? 0;
    message.unfilteredImplicitTransactionOps =
      object.unfilteredImplicitTransactionOps?.map((e) => TrxOp.fromPartial(e)) || [];
    message.filteredImplicitTransactionOps = object.filteredImplicitTransactionOps?.map((e) => TrxOp.fromPartial(e)) ||
      [];
    message.unfilteredTransactionTraces =
      object.unfilteredTransactionTraces?.map((e) => TransactionTrace.fromPartial(e)) || [];
    message.filteredTransactionTraces = object.filteredTransactionTraces?.map((e) => TransactionTrace.fromPartial(e)) ||
      [];
    message.unfilteredTransactionTraceCount = object.unfilteredTransactionTraceCount ?? 0;
    message.filteredTransactionTraceCount = object.filteredTransactionTraceCount ?? 0;
    message.unfilteredExecutedInputActionCount = object.unfilteredExecutedInputActionCount ?? 0;
    message.filteredExecutedInputActionCount = object.filteredExecutedInputActionCount ?? 0;
    message.unfilteredExecutedTotalActionCount = object.unfilteredExecutedTotalActionCount ?? 0;
    message.filteredExecutedTotalActionCount = object.filteredExecutedTotalActionCount ?? 0;
    message.blockSigningKey = object.blockSigningKey ?? "";
    message.activeScheduleV1 = (object.activeScheduleV1 !== undefined && object.activeScheduleV1 !== null)
      ? ProducerSchedule.fromPartial(object.activeScheduleV1)
      : undefined;
    message.validBlockSigningAuthorityV2 =
      (object.validBlockSigningAuthorityV2 !== undefined && object.validBlockSigningAuthorityV2 !== null)
        ? BlockSigningAuthority.fromPartial(object.validBlockSigningAuthorityV2)
        : undefined;
    message.activeScheduleV2 = (object.activeScheduleV2 !== undefined && object.activeScheduleV2 !== null)
      ? ProducerAuthoritySchedule.fromPartial(object.activeScheduleV2)
      : undefined;
    message.filteringApplied = object.filteringApplied ?? false;
    message.filteringIncludeFilterExpr = object.filteringIncludeFilterExpr ?? "";
    message.filteringExcludeFilterExpr = object.filteringExcludeFilterExpr ?? "";
    message.filteringSystemActionsIncludeFilterExpr = object.filteringSystemActionsIncludeFilterExpr ?? "";
    return message;
  },
};

function createBaseFinalityData(): FinalityData {
  return {
    majorVersion: 0,
    minorVersion: 0,
    activeFinalizerPolicyGeneration: 0,
    actionMroot: new Uint8Array(0),
    reversibleBlocksMroot: new Uint8Array(0),
    latestQcClaimBlockNum: 0,
    latestQcClaimFinalityDigest: new Uint8Array(0),
    latestQcClaimTimestamp: undefined,
    baseDigest: new Uint8Array(0),
    pendingFinalizerPolicy: undefined,
    lastPendingFinalizerPolicyGeneration: 0,
  };
}

export const FinalityData: MessageFns<FinalityData> = {
  encode(message: FinalityData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.majorVersion !== 0) {
      writer.uint32(8).uint32(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      writer.uint32(16).uint32(message.minorVersion);
    }
    if (message.activeFinalizerPolicyGeneration !== 0) {
      writer.uint32(24).uint32(message.activeFinalizerPolicyGeneration);
    }
    if (message.actionMroot.length !== 0) {
      writer.uint32(34).bytes(message.actionMroot);
    }
    if (message.reversibleBlocksMroot.length !== 0) {
      writer.uint32(42).bytes(message.reversibleBlocksMroot);
    }
    if (message.latestQcClaimBlockNum !== 0) {
      writer.uint32(48).uint32(message.latestQcClaimBlockNum);
    }
    if (message.latestQcClaimFinalityDigest.length !== 0) {
      writer.uint32(58).bytes(message.latestQcClaimFinalityDigest);
    }
    if (message.latestQcClaimTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.latestQcClaimTimestamp), writer.uint32(66).fork()).join();
    }
    if (message.baseDigest.length !== 0) {
      writer.uint32(74).bytes(message.baseDigest);
    }
    if (message.pendingFinalizerPolicy !== undefined) {
      FinalizerPolicy.encode(message.pendingFinalizerPolicy, writer.uint32(82).fork()).join();
    }
    if (message.lastPendingFinalizerPolicyGeneration !== 0) {
      writer.uint32(88).uint32(message.lastPendingFinalizerPolicyGeneration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalityData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalityData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.majorVersion = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minorVersion = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.activeFinalizerPolicyGeneration = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.actionMroot = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reversibleBlocksMroot = reader.bytes();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.latestQcClaimBlockNum = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.latestQcClaimFinalityDigest = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.latestQcClaimTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.baseDigest = reader.bytes();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.pendingFinalizerPolicy = FinalizerPolicy.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.lastPendingFinalizerPolicyGeneration = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalityData {
    return {
      majorVersion: isSet(object.majorVersion) ? globalThis.Number(object.majorVersion) : 0,
      minorVersion: isSet(object.minorVersion) ? globalThis.Number(object.minorVersion) : 0,
      activeFinalizerPolicyGeneration: isSet(object.activeFinalizerPolicyGeneration)
        ? globalThis.Number(object.activeFinalizerPolicyGeneration)
        : 0,
      actionMroot: isSet(object.actionMroot) ? bytesFromBase64(object.actionMroot) : new Uint8Array(0),
      reversibleBlocksMroot: isSet(object.reversibleBlocksMroot)
        ? bytesFromBase64(object.reversibleBlocksMroot)
        : new Uint8Array(0),
      latestQcClaimBlockNum: isSet(object.latestQcClaimBlockNum) ? globalThis.Number(object.latestQcClaimBlockNum) : 0,
      latestQcClaimFinalityDigest: isSet(object.latestQcClaimFinalityDigest)
        ? bytesFromBase64(object.latestQcClaimFinalityDigest)
        : new Uint8Array(0),
      latestQcClaimTimestamp: isSet(object.latestQcClaimTimestamp)
        ? fromJsonTimestamp(object.latestQcClaimTimestamp)
        : undefined,
      baseDigest: isSet(object.baseDigest) ? bytesFromBase64(object.baseDigest) : new Uint8Array(0),
      pendingFinalizerPolicy: isSet(object.pendingFinalizerPolicy)
        ? FinalizerPolicy.fromJSON(object.pendingFinalizerPolicy)
        : undefined,
      lastPendingFinalizerPolicyGeneration: isSet(object.lastPendingFinalizerPolicyGeneration)
        ? globalThis.Number(object.lastPendingFinalizerPolicyGeneration)
        : 0,
    };
  },

  toJSON(message: FinalityData): unknown {
    const obj: any = {};
    if (message.majorVersion !== 0) {
      obj.majorVersion = Math.round(message.majorVersion);
    }
    if (message.minorVersion !== 0) {
      obj.minorVersion = Math.round(message.minorVersion);
    }
    if (message.activeFinalizerPolicyGeneration !== 0) {
      obj.activeFinalizerPolicyGeneration = Math.round(message.activeFinalizerPolicyGeneration);
    }
    if (message.actionMroot.length !== 0) {
      obj.actionMroot = base64FromBytes(message.actionMroot);
    }
    if (message.reversibleBlocksMroot.length !== 0) {
      obj.reversibleBlocksMroot = base64FromBytes(message.reversibleBlocksMroot);
    }
    if (message.latestQcClaimBlockNum !== 0) {
      obj.latestQcClaimBlockNum = Math.round(message.latestQcClaimBlockNum);
    }
    if (message.latestQcClaimFinalityDigest.length !== 0) {
      obj.latestQcClaimFinalityDigest = base64FromBytes(message.latestQcClaimFinalityDigest);
    }
    if (message.latestQcClaimTimestamp !== undefined) {
      obj.latestQcClaimTimestamp = message.latestQcClaimTimestamp.toISOString();
    }
    if (message.baseDigest.length !== 0) {
      obj.baseDigest = base64FromBytes(message.baseDigest);
    }
    if (message.pendingFinalizerPolicy !== undefined) {
      obj.pendingFinalizerPolicy = FinalizerPolicy.toJSON(message.pendingFinalizerPolicy);
    }
    if (message.lastPendingFinalizerPolicyGeneration !== 0) {
      obj.lastPendingFinalizerPolicyGeneration = Math.round(message.lastPendingFinalizerPolicyGeneration);
    }
    return obj;
  },

  create(base?: DeepPartial<FinalityData>): FinalityData {
    return FinalityData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalityData>): FinalityData {
    const message = createBaseFinalityData();
    message.majorVersion = object.majorVersion ?? 0;
    message.minorVersion = object.minorVersion ?? 0;
    message.activeFinalizerPolicyGeneration = object.activeFinalizerPolicyGeneration ?? 0;
    message.actionMroot = object.actionMroot ?? new Uint8Array(0);
    message.reversibleBlocksMroot = object.reversibleBlocksMroot ?? new Uint8Array(0);
    message.latestQcClaimBlockNum = object.latestQcClaimBlockNum ?? 0;
    message.latestQcClaimFinalityDigest = object.latestQcClaimFinalityDigest ?? new Uint8Array(0);
    message.latestQcClaimTimestamp = object.latestQcClaimTimestamp ?? undefined;
    message.baseDigest = object.baseDigest ?? new Uint8Array(0);
    message.pendingFinalizerPolicy =
      (object.pendingFinalizerPolicy !== undefined && object.pendingFinalizerPolicy !== null)
        ? FinalizerPolicy.fromPartial(object.pendingFinalizerPolicy)
        : undefined;
    message.lastPendingFinalizerPolicyGeneration = object.lastPendingFinalizerPolicyGeneration ?? 0;
    return message;
  },
};

function createBaseFinalizerPolicy(): FinalizerPolicy {
  return { generation: 0, threshold: 0, finalizers: [] };
}

export const FinalizerPolicy: MessageFns<FinalizerPolicy> = {
  encode(message: FinalizerPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generation !== 0) {
      writer.uint32(8).uint32(message.generation);
    }
    if (message.threshold !== 0) {
      writer.uint32(16).uint64(message.threshold);
    }
    for (const v of message.finalizers) {
      FinalizerAuthority.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizerPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizerPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.generation = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threshold = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.finalizers.push(FinalizerAuthority.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizerPolicy {
    return {
      generation: isSet(object.generation) ? globalThis.Number(object.generation) : 0,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      finalizers: globalThis.Array.isArray(object?.finalizers)
        ? object.finalizers.map((e: any) => FinalizerAuthority.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FinalizerPolicy): unknown {
    const obj: any = {};
    if (message.generation !== 0) {
      obj.generation = Math.round(message.generation);
    }
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    if (message.finalizers?.length) {
      obj.finalizers = message.finalizers.map((e) => FinalizerAuthority.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizerPolicy>): FinalizerPolicy {
    return FinalizerPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizerPolicy>): FinalizerPolicy {
    const message = createBaseFinalizerPolicy();
    message.generation = object.generation ?? 0;
    message.threshold = object.threshold ?? 0;
    message.finalizers = object.finalizers?.map((e) => FinalizerAuthority.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinalizerAuthority(): FinalizerAuthority {
  return { description: "", weight: 0, publicKey: "" };
}

export const FinalizerAuthority: MessageFns<FinalizerAuthority> = {
  encode(message: FinalizerAuthority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.weight !== 0) {
      writer.uint32(16).uint64(message.weight);
    }
    if (message.publicKey !== "") {
      writer.uint32(26).string(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizerAuthority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizerAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.weight = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizerAuthority {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
    };
  },

  toJSON(message: FinalizerAuthority): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizerAuthority>): FinalizerAuthority {
    return FinalizerAuthority.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizerAuthority>): FinalizerAuthority {
    const message = createBaseFinalizerAuthority();
    message.description = object.description ?? "";
    message.weight = object.weight ?? 0;
    message.publicKey = object.publicKey ?? "";
    return message;
  },
};

function createBaseBlockWithRefs(): BlockWithRefs {
  return {
    id: "",
    block: undefined,
    implicitTransactionRefs: undefined,
    transactionRefs: undefined,
    transactionTraceRefs: undefined,
    irreversible: false,
  };
}

export const BlockWithRefs: MessageFns<BlockWithRefs> = {
  encode(message: BlockWithRefs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.block !== undefined) {
      Block.encode(message.block, writer.uint32(18).fork()).join();
    }
    if (message.implicitTransactionRefs !== undefined) {
      TransactionRefs.encode(message.implicitTransactionRefs, writer.uint32(26).fork()).join();
    }
    if (message.transactionRefs !== undefined) {
      TransactionRefs.encode(message.transactionRefs, writer.uint32(34).fork()).join();
    }
    if (message.transactionTraceRefs !== undefined) {
      TransactionRefs.encode(message.transactionTraceRefs, writer.uint32(42).fork()).join();
    }
    if (message.irreversible !== false) {
      writer.uint32(48).bool(message.irreversible);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockWithRefs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockWithRefs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.block = Block.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.implicitTransactionRefs = TransactionRefs.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionRefs = TransactionRefs.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionTraceRefs = TransactionRefs.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.irreversible = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockWithRefs {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      block: isSet(object.block) ? Block.fromJSON(object.block) : undefined,
      implicitTransactionRefs: isSet(object.implicitTransactionRefs)
        ? TransactionRefs.fromJSON(object.implicitTransactionRefs)
        : undefined,
      transactionRefs: isSet(object.transactionRefs) ? TransactionRefs.fromJSON(object.transactionRefs) : undefined,
      transactionTraceRefs: isSet(object.transactionTraceRefs)
        ? TransactionRefs.fromJSON(object.transactionTraceRefs)
        : undefined,
      irreversible: isSet(object.irreversible) ? globalThis.Boolean(object.irreversible) : false,
    };
  },

  toJSON(message: BlockWithRefs): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.block !== undefined) {
      obj.block = Block.toJSON(message.block);
    }
    if (message.implicitTransactionRefs !== undefined) {
      obj.implicitTransactionRefs = TransactionRefs.toJSON(message.implicitTransactionRefs);
    }
    if (message.transactionRefs !== undefined) {
      obj.transactionRefs = TransactionRefs.toJSON(message.transactionRefs);
    }
    if (message.transactionTraceRefs !== undefined) {
      obj.transactionTraceRefs = TransactionRefs.toJSON(message.transactionTraceRefs);
    }
    if (message.irreversible !== false) {
      obj.irreversible = message.irreversible;
    }
    return obj;
  },

  create(base?: DeepPartial<BlockWithRefs>): BlockWithRefs {
    return BlockWithRefs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockWithRefs>): BlockWithRefs {
    const message = createBaseBlockWithRefs();
    message.id = object.id ?? "";
    message.block = (object.block !== undefined && object.block !== null) ? Block.fromPartial(object.block) : undefined;
    message.implicitTransactionRefs =
      (object.implicitTransactionRefs !== undefined && object.implicitTransactionRefs !== null)
        ? TransactionRefs.fromPartial(object.implicitTransactionRefs)
        : undefined;
    message.transactionRefs = (object.transactionRefs !== undefined && object.transactionRefs !== null)
      ? TransactionRefs.fromPartial(object.transactionRefs)
      : undefined;
    message.transactionTraceRefs = (object.transactionTraceRefs !== undefined && object.transactionTraceRefs !== null)
      ? TransactionRefs.fromPartial(object.transactionTraceRefs)
      : undefined;
    message.irreversible = object.irreversible ?? false;
    return message;
  },
};

function createBaseTransactionRefs(): TransactionRefs {
  return { hashes: [] };
}

export const TransactionRefs: MessageFns<TransactionRefs> = {
  encode(message: TransactionRefs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.hashes) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionRefs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionRefs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hashes.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionRefs {
    return {
      hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: TransactionRefs): unknown {
    const obj: any = {};
    if (message.hashes?.length) {
      obj.hashes = message.hashes.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionRefs>): TransactionRefs {
    return TransactionRefs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionRefs>): TransactionRefs {
    const message = createBaseTransactionRefs();
    message.hashes = object.hashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseActivatedProtocolFeatures(): ActivatedProtocolFeatures {
  return { protocolFeatures: [] };
}

export const ActivatedProtocolFeatures: MessageFns<ActivatedProtocolFeatures> = {
  encode(message: ActivatedProtocolFeatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.protocolFeatures) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivatedProtocolFeatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivatedProtocolFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.protocolFeatures.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivatedProtocolFeatures {
    return {
      protocolFeatures: globalThis.Array.isArray(object?.protocolFeatures)
        ? object.protocolFeatures.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: ActivatedProtocolFeatures): unknown {
    const obj: any = {};
    if (message.protocolFeatures?.length) {
      obj.protocolFeatures = message.protocolFeatures.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ActivatedProtocolFeatures>): ActivatedProtocolFeatures {
    return ActivatedProtocolFeatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActivatedProtocolFeatures>): ActivatedProtocolFeatures {
    const message = createBaseActivatedProtocolFeatures();
    message.protocolFeatures = object.protocolFeatures?.map((e) => e) || [];
    return message;
  },
};

function createBasePendingProducerSchedule(): PendingProducerSchedule {
  return { scheduleLibNum: 0, scheduleHash: new Uint8Array(0), scheduleV1: undefined, scheduleV2: undefined };
}

export const PendingProducerSchedule: MessageFns<PendingProducerSchedule> = {
  encode(message: PendingProducerSchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduleLibNum !== 0) {
      writer.uint32(8).uint32(message.scheduleLibNum);
    }
    if (message.scheduleHash.length !== 0) {
      writer.uint32(18).bytes(message.scheduleHash);
    }
    if (message.scheduleV1 !== undefined) {
      ProducerSchedule.encode(message.scheduleV1, writer.uint32(26).fork()).join();
    }
    if (message.scheduleV2 !== undefined) {
      ProducerAuthoritySchedule.encode(message.scheduleV2, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingProducerSchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingProducerSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scheduleLibNum = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scheduleHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.scheduleV1 = ProducerSchedule.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.scheduleV2 = ProducerAuthoritySchedule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingProducerSchedule {
    return {
      scheduleLibNum: isSet(object.scheduleLibNum) ? globalThis.Number(object.scheduleLibNum) : 0,
      scheduleHash: isSet(object.scheduleHash) ? bytesFromBase64(object.scheduleHash) : new Uint8Array(0),
      scheduleV1: isSet(object.scheduleV1) ? ProducerSchedule.fromJSON(object.scheduleV1) : undefined,
      scheduleV2: isSet(object.scheduleV2) ? ProducerAuthoritySchedule.fromJSON(object.scheduleV2) : undefined,
    };
  },

  toJSON(message: PendingProducerSchedule): unknown {
    const obj: any = {};
    if (message.scheduleLibNum !== 0) {
      obj.scheduleLibNum = Math.round(message.scheduleLibNum);
    }
    if (message.scheduleHash.length !== 0) {
      obj.scheduleHash = base64FromBytes(message.scheduleHash);
    }
    if (message.scheduleV1 !== undefined) {
      obj.scheduleV1 = ProducerSchedule.toJSON(message.scheduleV1);
    }
    if (message.scheduleV2 !== undefined) {
      obj.scheduleV2 = ProducerAuthoritySchedule.toJSON(message.scheduleV2);
    }
    return obj;
  },

  create(base?: DeepPartial<PendingProducerSchedule>): PendingProducerSchedule {
    return PendingProducerSchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PendingProducerSchedule>): PendingProducerSchedule {
    const message = createBasePendingProducerSchedule();
    message.scheduleLibNum = object.scheduleLibNum ?? 0;
    message.scheduleHash = object.scheduleHash ?? new Uint8Array(0);
    message.scheduleV1 = (object.scheduleV1 !== undefined && object.scheduleV1 !== null)
      ? ProducerSchedule.fromPartial(object.scheduleV1)
      : undefined;
    message.scheduleV2 = (object.scheduleV2 !== undefined && object.scheduleV2 !== null)
      ? ProducerAuthoritySchedule.fromPartial(object.scheduleV2)
      : undefined;
    return message;
  },
};

function createBaseProducerSchedule(): ProducerSchedule {
  return { version: 0, producers: [] };
}

export const ProducerSchedule: MessageFns<ProducerSchedule> = {
  encode(message: ProducerSchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    for (const v of message.producers) {
      ProducerKey.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProducerSchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProducerSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.producers.push(ProducerKey.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProducerSchedule {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      producers: globalThis.Array.isArray(object?.producers)
        ? object.producers.map((e: any) => ProducerKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProducerSchedule): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.producers?.length) {
      obj.producers = message.producers.map((e) => ProducerKey.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProducerSchedule>): ProducerSchedule {
    return ProducerSchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProducerSchedule>): ProducerSchedule {
    const message = createBaseProducerSchedule();
    message.version = object.version ?? 0;
    message.producers = object.producers?.map((e) => ProducerKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProducerKey(): ProducerKey {
  return { accountName: "", blockSigningKey: "" };
}

export const ProducerKey: MessageFns<ProducerKey> = {
  encode(message: ProducerKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountName !== "") {
      writer.uint32(10).string(message.accountName);
    }
    if (message.blockSigningKey !== "") {
      writer.uint32(18).string(message.blockSigningKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProducerKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProducerKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockSigningKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProducerKey {
    return {
      accountName: isSet(object.accountName) ? globalThis.String(object.accountName) : "",
      blockSigningKey: isSet(object.blockSigningKey) ? globalThis.String(object.blockSigningKey) : "",
    };
  },

  toJSON(message: ProducerKey): unknown {
    const obj: any = {};
    if (message.accountName !== "") {
      obj.accountName = message.accountName;
    }
    if (message.blockSigningKey !== "") {
      obj.blockSigningKey = message.blockSigningKey;
    }
    return obj;
  },

  create(base?: DeepPartial<ProducerKey>): ProducerKey {
    return ProducerKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProducerKey>): ProducerKey {
    const message = createBaseProducerKey();
    message.accountName = object.accountName ?? "";
    message.blockSigningKey = object.blockSigningKey ?? "";
    return message;
  },
};

function createBaseProducerAuthoritySchedule(): ProducerAuthoritySchedule {
  return { version: 0, producers: [] };
}

export const ProducerAuthoritySchedule: MessageFns<ProducerAuthoritySchedule> = {
  encode(message: ProducerAuthoritySchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    for (const v of message.producers) {
      ProducerAuthority.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProducerAuthoritySchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProducerAuthoritySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.producers.push(ProducerAuthority.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProducerAuthoritySchedule {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      producers: globalThis.Array.isArray(object?.producers)
        ? object.producers.map((e: any) => ProducerAuthority.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProducerAuthoritySchedule): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.producers?.length) {
      obj.producers = message.producers.map((e) => ProducerAuthority.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProducerAuthoritySchedule>): ProducerAuthoritySchedule {
    return ProducerAuthoritySchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProducerAuthoritySchedule>): ProducerAuthoritySchedule {
    const message = createBaseProducerAuthoritySchedule();
    message.version = object.version ?? 0;
    message.producers = object.producers?.map((e) => ProducerAuthority.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProducerAuthority(): ProducerAuthority {
  return { accountName: "", blockSigningAuthority: undefined };
}

export const ProducerAuthority: MessageFns<ProducerAuthority> = {
  encode(message: ProducerAuthority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountName !== "") {
      writer.uint32(10).string(message.accountName);
    }
    if (message.blockSigningAuthority !== undefined) {
      BlockSigningAuthority.encode(message.blockSigningAuthority, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProducerAuthority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProducerAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockSigningAuthority = BlockSigningAuthority.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProducerAuthority {
    return {
      accountName: isSet(object.accountName) ? globalThis.String(object.accountName) : "",
      blockSigningAuthority: isSet(object.blockSigningAuthority)
        ? BlockSigningAuthority.fromJSON(object.blockSigningAuthority)
        : undefined,
    };
  },

  toJSON(message: ProducerAuthority): unknown {
    const obj: any = {};
    if (message.accountName !== "") {
      obj.accountName = message.accountName;
    }
    if (message.blockSigningAuthority !== undefined) {
      obj.blockSigningAuthority = BlockSigningAuthority.toJSON(message.blockSigningAuthority);
    }
    return obj;
  },

  create(base?: DeepPartial<ProducerAuthority>): ProducerAuthority {
    return ProducerAuthority.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProducerAuthority>): ProducerAuthority {
    const message = createBaseProducerAuthority();
    message.accountName = object.accountName ?? "";
    message.blockSigningAuthority =
      (object.blockSigningAuthority !== undefined && object.blockSigningAuthority !== null)
        ? BlockSigningAuthority.fromPartial(object.blockSigningAuthority)
        : undefined;
    return message;
  },
};

function createBaseProposerPolicy(): ProposerPolicy {
  return { activeTime: undefined, proposerSchedule: undefined };
}

export const ProposerPolicy: MessageFns<ProposerPolicy> = {
  encode(message: ProposerPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.activeTime), writer.uint32(10).fork()).join();
    }
    if (message.proposerSchedule !== undefined) {
      ProducerAuthoritySchedule.encode(message.proposerSchedule, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProposerPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProposerPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.activeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.proposerSchedule = ProducerAuthoritySchedule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProposerPolicy {
    return {
      activeTime: isSet(object.activeTime) ? fromJsonTimestamp(object.activeTime) : undefined,
      proposerSchedule: isSet(object.proposerSchedule)
        ? ProducerAuthoritySchedule.fromJSON(object.proposerSchedule)
        : undefined,
    };
  },

  toJSON(message: ProposerPolicy): unknown {
    const obj: any = {};
    if (message.activeTime !== undefined) {
      obj.activeTime = message.activeTime.toISOString();
    }
    if (message.proposerSchedule !== undefined) {
      obj.proposerSchedule = ProducerAuthoritySchedule.toJSON(message.proposerSchedule);
    }
    return obj;
  },

  create(base?: DeepPartial<ProposerPolicy>): ProposerPolicy {
    return ProposerPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProposerPolicy>): ProposerPolicy {
    const message = createBaseProposerPolicy();
    message.activeTime = object.activeTime ?? undefined;
    message.proposerSchedule = (object.proposerSchedule !== undefined && object.proposerSchedule !== null)
      ? ProducerAuthoritySchedule.fromPartial(object.proposerSchedule)
      : undefined;
    return message;
  },
};

function createBaseBlockSigningAuthority(): BlockSigningAuthority {
  return { v0: undefined };
}

export const BlockSigningAuthority: MessageFns<BlockSigningAuthority> = {
  encode(message: BlockSigningAuthority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.v0 !== undefined) {
      BlockSigningAuthorityV0.encode(message.v0, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockSigningAuthority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockSigningAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.v0 = BlockSigningAuthorityV0.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockSigningAuthority {
    return { v0: isSet(object.v0) ? BlockSigningAuthorityV0.fromJSON(object.v0) : undefined };
  },

  toJSON(message: BlockSigningAuthority): unknown {
    const obj: any = {};
    if (message.v0 !== undefined) {
      obj.v0 = BlockSigningAuthorityV0.toJSON(message.v0);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockSigningAuthority>): BlockSigningAuthority {
    return BlockSigningAuthority.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockSigningAuthority>): BlockSigningAuthority {
    const message = createBaseBlockSigningAuthority();
    message.v0 = (object.v0 !== undefined && object.v0 !== null)
      ? BlockSigningAuthorityV0.fromPartial(object.v0)
      : undefined;
    return message;
  },
};

function createBaseBlockSigningAuthorityV0(): BlockSigningAuthorityV0 {
  return { threshold: 0, keys: [] };
}

export const BlockSigningAuthorityV0: MessageFns<BlockSigningAuthorityV0> = {
  encode(message: BlockSigningAuthorityV0, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threshold !== 0) {
      writer.uint32(8).uint32(message.threshold);
    }
    for (const v of message.keys) {
      KeyWeight.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockSigningAuthorityV0 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockSigningAuthorityV0();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keys.push(KeyWeight.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockSigningAuthorityV0 {
    return {
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => KeyWeight.fromJSON(e)) : [],
    };
  },

  toJSON(message: BlockSigningAuthorityV0): unknown {
    const obj: any = {};
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => KeyWeight.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BlockSigningAuthorityV0>): BlockSigningAuthorityV0 {
    return BlockSigningAuthorityV0.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockSigningAuthorityV0>): BlockSigningAuthorityV0 {
    const message = createBaseBlockSigningAuthorityV0();
    message.threshold = object.threshold ?? 0;
    message.keys = object.keys?.map((e) => KeyWeight.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockRootMerkle(): BlockRootMerkle {
  return { nodeCount: 0, activeNodes: [] };
}

export const BlockRootMerkle: MessageFns<BlockRootMerkle> = {
  encode(message: BlockRootMerkle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeCount !== 0) {
      writer.uint32(8).uint32(message.nodeCount);
    }
    for (const v of message.activeNodes) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockRootMerkle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockRootMerkle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeCount = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.activeNodes.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockRootMerkle {
    return {
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      activeNodes: globalThis.Array.isArray(object?.activeNodes)
        ? object.activeNodes.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: BlockRootMerkle): unknown {
    const obj: any = {};
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.activeNodes?.length) {
      obj.activeNodes = message.activeNodes.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BlockRootMerkle>): BlockRootMerkle {
    return BlockRootMerkle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockRootMerkle>): BlockRootMerkle {
    const message = createBaseBlockRootMerkle();
    message.nodeCount = object.nodeCount ?? 0;
    message.activeNodes = object.activeNodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseProducerToLastProduced(): ProducerToLastProduced {
  return { name: "", lastBlockNumProduced: 0 };
}

export const ProducerToLastProduced: MessageFns<ProducerToLastProduced> = {
  encode(message: ProducerToLastProduced, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.lastBlockNumProduced !== 0) {
      writer.uint32(16).uint32(message.lastBlockNumProduced);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProducerToLastProduced {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProducerToLastProduced();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lastBlockNumProduced = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProducerToLastProduced {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      lastBlockNumProduced: isSet(object.lastBlockNumProduced) ? globalThis.Number(object.lastBlockNumProduced) : 0,
    };
  },

  toJSON(message: ProducerToLastProduced): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.lastBlockNumProduced !== 0) {
      obj.lastBlockNumProduced = Math.round(message.lastBlockNumProduced);
    }
    return obj;
  },

  create(base?: DeepPartial<ProducerToLastProduced>): ProducerToLastProduced {
    return ProducerToLastProduced.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProducerToLastProduced>): ProducerToLastProduced {
    const message = createBaseProducerToLastProduced();
    message.name = object.name ?? "";
    message.lastBlockNumProduced = object.lastBlockNumProduced ?? 0;
    return message;
  },
};

function createBaseProducerToLastImpliedIRB(): ProducerToLastImpliedIRB {
  return { name: "", lastBlockNumProduced: 0 };
}

export const ProducerToLastImpliedIRB: MessageFns<ProducerToLastImpliedIRB> = {
  encode(message: ProducerToLastImpliedIRB, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.lastBlockNumProduced !== 0) {
      writer.uint32(16).uint32(message.lastBlockNumProduced);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProducerToLastImpliedIRB {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProducerToLastImpliedIRB();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lastBlockNumProduced = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProducerToLastImpliedIRB {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      lastBlockNumProduced: isSet(object.lastBlockNumProduced) ? globalThis.Number(object.lastBlockNumProduced) : 0,
    };
  },

  toJSON(message: ProducerToLastImpliedIRB): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.lastBlockNumProduced !== 0) {
      obj.lastBlockNumProduced = Math.round(message.lastBlockNumProduced);
    }
    return obj;
  },

  create(base?: DeepPartial<ProducerToLastImpliedIRB>): ProducerToLastImpliedIRB {
    return ProducerToLastImpliedIRB.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProducerToLastImpliedIRB>): ProducerToLastImpliedIRB {
    const message = createBaseProducerToLastImpliedIRB();
    message.name = object.name ?? "";
    message.lastBlockNumProduced = object.lastBlockNumProduced ?? 0;
    return message;
  },
};

function createBaseTransactionReceipt(): TransactionReceipt {
  return { id: "", index: 0, status: 0, cpuUsageMicroSeconds: 0, netUsageWords: 0, packedTransaction: undefined };
}

export const TransactionReceipt: MessageFns<TransactionReceipt> = {
  encode(message: TransactionReceipt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.index !== 0) {
      writer.uint32(48).uint64(message.index);
    }
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.cpuUsageMicroSeconds !== 0) {
      writer.uint32(16).uint32(message.cpuUsageMicroSeconds);
    }
    if (message.netUsageWords !== 0) {
      writer.uint32(24).uint32(message.netUsageWords);
    }
    if (message.packedTransaction !== undefined) {
      PackedTransaction.encode(message.packedTransaction, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionReceipt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.index = longToNumber(reader.uint64());
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cpuUsageMicroSeconds = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.netUsageWords = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.packedTransaction = PackedTransaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionReceipt {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      status: isSet(object.status) ? transactionStatusFromJSON(object.status) : 0,
      cpuUsageMicroSeconds: isSet(object.cpuUsageMicroSeconds) ? globalThis.Number(object.cpuUsageMicroSeconds) : 0,
      netUsageWords: isSet(object.netUsageWords) ? globalThis.Number(object.netUsageWords) : 0,
      packedTransaction: isSet(object.packedTransaction)
        ? PackedTransaction.fromJSON(object.packedTransaction)
        : undefined,
    };
  },

  toJSON(message: TransactionReceipt): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.status !== 0) {
      obj.status = transactionStatusToJSON(message.status);
    }
    if (message.cpuUsageMicroSeconds !== 0) {
      obj.cpuUsageMicroSeconds = Math.round(message.cpuUsageMicroSeconds);
    }
    if (message.netUsageWords !== 0) {
      obj.netUsageWords = Math.round(message.netUsageWords);
    }
    if (message.packedTransaction !== undefined) {
      obj.packedTransaction = PackedTransaction.toJSON(message.packedTransaction);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionReceipt>): TransactionReceipt {
    return TransactionReceipt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionReceipt>): TransactionReceipt {
    const message = createBaseTransactionReceipt();
    message.id = object.id ?? "";
    message.index = object.index ?? 0;
    message.status = object.status ?? 0;
    message.cpuUsageMicroSeconds = object.cpuUsageMicroSeconds ?? 0;
    message.netUsageWords = object.netUsageWords ?? 0;
    message.packedTransaction = (object.packedTransaction !== undefined && object.packedTransaction !== null)
      ? PackedTransaction.fromPartial(object.packedTransaction)
      : undefined;
    return message;
  },
};

function createBasePackedTransaction(): PackedTransaction {
  return {
    signatures: [],
    compression: 0,
    packedContextFreeData: new Uint8Array(0),
    packedTransaction: new Uint8Array(0),
  };
}

export const PackedTransaction: MessageFns<PackedTransaction> = {
  encode(message: PackedTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signatures) {
      writer.uint32(10).string(v!);
    }
    if (message.compression !== 0) {
      writer.uint32(16).uint32(message.compression);
    }
    if (message.packedContextFreeData.length !== 0) {
      writer.uint32(26).bytes(message.packedContextFreeData);
    }
    if (message.packedTransaction.length !== 0) {
      writer.uint32(34).bytes(message.packedTransaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PackedTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackedTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signatures.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.compression = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.packedContextFreeData = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.packedTransaction = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PackedTransaction {
    return {
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => globalThis.String(e))
        : [],
      compression: isSet(object.compression) ? globalThis.Number(object.compression) : 0,
      packedContextFreeData: isSet(object.packedContextFreeData)
        ? bytesFromBase64(object.packedContextFreeData)
        : new Uint8Array(0),
      packedTransaction: isSet(object.packedTransaction)
        ? bytesFromBase64(object.packedTransaction)
        : new Uint8Array(0),
    };
  },

  toJSON(message: PackedTransaction): unknown {
    const obj: any = {};
    if (message.signatures?.length) {
      obj.signatures = message.signatures;
    }
    if (message.compression !== 0) {
      obj.compression = Math.round(message.compression);
    }
    if (message.packedContextFreeData.length !== 0) {
      obj.packedContextFreeData = base64FromBytes(message.packedContextFreeData);
    }
    if (message.packedTransaction.length !== 0) {
      obj.packedTransaction = base64FromBytes(message.packedTransaction);
    }
    return obj;
  },

  create(base?: DeepPartial<PackedTransaction>): PackedTransaction {
    return PackedTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PackedTransaction>): PackedTransaction {
    const message = createBasePackedTransaction();
    message.signatures = object.signatures?.map((e) => e) || [];
    message.compression = object.compression ?? 0;
    message.packedContextFreeData = object.packedContextFreeData ?? new Uint8Array(0);
    message.packedTransaction = object.packedTransaction ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBlockHeader(): BlockHeader {
  return {
    timestamp: undefined,
    producer: "",
    confirmed: 0,
    previous: "",
    transactionMroot: new Uint8Array(0),
    actionMroot: new Uint8Array(0),
    scheduleVersion: 0,
    headerExtensions: [],
    decodedHeaderExtensions: [],
    newProducersV1: undefined,
  };
}

export const BlockHeader: MessageFns<BlockHeader> = {
  encode(message: BlockHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    if (message.producer !== "") {
      writer.uint32(34).string(message.producer);
    }
    if (message.confirmed !== 0) {
      writer.uint32(40).uint32(message.confirmed);
    }
    if (message.previous !== "") {
      writer.uint32(50).string(message.previous);
    }
    if (message.transactionMroot.length !== 0) {
      writer.uint32(58).bytes(message.transactionMroot);
    }
    if (message.actionMroot.length !== 0) {
      writer.uint32(66).bytes(message.actionMroot);
    }
    if (message.scheduleVersion !== 0) {
      writer.uint32(72).uint32(message.scheduleVersion);
    }
    for (const v of message.headerExtensions) {
      Extension.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.decodedHeaderExtensions) {
      BlockHeaderExtension.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.newProducersV1 !== undefined) {
      ProducerSchedule.encode(message.newProducersV1, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.producer = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.confirmed = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.previous = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionMroot = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.actionMroot = reader.bytes();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.scheduleVersion = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.headerExtensions.push(Extension.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.decodedHeaderExtensions.push(BlockHeaderExtension.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.newProducersV1 = ProducerSchedule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeader {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      producer: isSet(object.producer) ? globalThis.String(object.producer) : "",
      confirmed: isSet(object.confirmed) ? globalThis.Number(object.confirmed) : 0,
      previous: isSet(object.previous) ? globalThis.String(object.previous) : "",
      transactionMroot: isSet(object.transactionMroot) ? bytesFromBase64(object.transactionMroot) : new Uint8Array(0),
      actionMroot: isSet(object.actionMroot) ? bytesFromBase64(object.actionMroot) : new Uint8Array(0),
      scheduleVersion: isSet(object.scheduleVersion) ? globalThis.Number(object.scheduleVersion) : 0,
      headerExtensions: globalThis.Array.isArray(object?.headerExtensions)
        ? object.headerExtensions.map((e: any) => Extension.fromJSON(e))
        : [],
      decodedHeaderExtensions: globalThis.Array.isArray(object?.decodedHeaderExtensions)
        ? object.decodedHeaderExtensions.map((e: any) => BlockHeaderExtension.fromJSON(e))
        : [],
      newProducersV1: isSet(object.newProducersV1) ? ProducerSchedule.fromJSON(object.newProducersV1) : undefined,
    };
  },

  toJSON(message: BlockHeader): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.producer !== "") {
      obj.producer = message.producer;
    }
    if (message.confirmed !== 0) {
      obj.confirmed = Math.round(message.confirmed);
    }
    if (message.previous !== "") {
      obj.previous = message.previous;
    }
    if (message.transactionMroot.length !== 0) {
      obj.transactionMroot = base64FromBytes(message.transactionMroot);
    }
    if (message.actionMroot.length !== 0) {
      obj.actionMroot = base64FromBytes(message.actionMroot);
    }
    if (message.scheduleVersion !== 0) {
      obj.scheduleVersion = Math.round(message.scheduleVersion);
    }
    if (message.headerExtensions?.length) {
      obj.headerExtensions = message.headerExtensions.map((e) => Extension.toJSON(e));
    }
    if (message.decodedHeaderExtensions?.length) {
      obj.decodedHeaderExtensions = message.decodedHeaderExtensions.map((e) => BlockHeaderExtension.toJSON(e));
    }
    if (message.newProducersV1 !== undefined) {
      obj.newProducersV1 = ProducerSchedule.toJSON(message.newProducersV1);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeader>): BlockHeader {
    return BlockHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeader>): BlockHeader {
    const message = createBaseBlockHeader();
    message.timestamp = object.timestamp ?? undefined;
    message.producer = object.producer ?? "";
    message.confirmed = object.confirmed ?? 0;
    message.previous = object.previous ?? "";
    message.transactionMroot = object.transactionMroot ?? new Uint8Array(0);
    message.actionMroot = object.actionMroot ?? new Uint8Array(0);
    message.scheduleVersion = object.scheduleVersion ?? 0;
    message.headerExtensions = object.headerExtensions?.map((e) => Extension.fromPartial(e)) || [];
    message.decodedHeaderExtensions = object.decodedHeaderExtensions?.map((e) => BlockHeaderExtension.fromPartial(e)) ||
      [];
    message.newProducersV1 = (object.newProducersV1 !== undefined && object.newProducersV1 !== null)
      ? ProducerSchedule.fromPartial(object.newProducersV1)
      : undefined;
    return message;
  },
};

function createBaseBlockHeaderExtension(): BlockHeaderExtension {
  return { protocolFeatureActivationExtension: undefined, producerScheduleChangeExtension: undefined };
}

export const BlockHeaderExtension: MessageFns<BlockHeaderExtension> = {
  encode(message: BlockHeaderExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolFeatureActivationExtension !== undefined) {
      ProtocolFeatureActivationExtension.encode(message.protocolFeatureActivationExtension, writer.uint32(10).fork())
        .join();
    }
    if (message.producerScheduleChangeExtension !== undefined) {
      ProducerScheduleChangeExtension.encode(message.producerScheduleChangeExtension, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeaderExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeaderExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.protocolFeatureActivationExtension = ProtocolFeatureActivationExtension.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.producerScheduleChangeExtension = ProducerScheduleChangeExtension.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeaderExtension {
    return {
      protocolFeatureActivationExtension: isSet(object.protocolFeatureActivationExtension)
        ? ProtocolFeatureActivationExtension.fromJSON(object.protocolFeatureActivationExtension)
        : undefined,
      producerScheduleChangeExtension: isSet(object.producerScheduleChangeExtension)
        ? ProducerScheduleChangeExtension.fromJSON(object.producerScheduleChangeExtension)
        : undefined,
    };
  },

  toJSON(message: BlockHeaderExtension): unknown {
    const obj: any = {};
    if (message.protocolFeatureActivationExtension !== undefined) {
      obj.protocolFeatureActivationExtension = ProtocolFeatureActivationExtension.toJSON(
        message.protocolFeatureActivationExtension,
      );
    }
    if (message.producerScheduleChangeExtension !== undefined) {
      obj.producerScheduleChangeExtension = ProducerScheduleChangeExtension.toJSON(
        message.producerScheduleChangeExtension,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeaderExtension>): BlockHeaderExtension {
    return BlockHeaderExtension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeaderExtension>): BlockHeaderExtension {
    const message = createBaseBlockHeaderExtension();
    message.protocolFeatureActivationExtension =
      (object.protocolFeatureActivationExtension !== undefined && object.protocolFeatureActivationExtension !== null)
        ? ProtocolFeatureActivationExtension.fromPartial(object.protocolFeatureActivationExtension)
        : undefined;
    message.producerScheduleChangeExtension =
      (object.producerScheduleChangeExtension !== undefined && object.producerScheduleChangeExtension !== null)
        ? ProducerScheduleChangeExtension.fromPartial(object.producerScheduleChangeExtension)
        : undefined;
    return message;
  },
};

function createBaseProtocolFeatureActivationExtension(): ProtocolFeatureActivationExtension {
  return { protocolFeatures: [] };
}

export const ProtocolFeatureActivationExtension: MessageFns<ProtocolFeatureActivationExtension> = {
  encode(message: ProtocolFeatureActivationExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.protocolFeatures) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtocolFeatureActivationExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtocolFeatureActivationExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.protocolFeatures.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtocolFeatureActivationExtension {
    return {
      protocolFeatures: globalThis.Array.isArray(object?.protocolFeatures)
        ? object.protocolFeatures.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: ProtocolFeatureActivationExtension): unknown {
    const obj: any = {};
    if (message.protocolFeatures?.length) {
      obj.protocolFeatures = message.protocolFeatures.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProtocolFeatureActivationExtension>): ProtocolFeatureActivationExtension {
    return ProtocolFeatureActivationExtension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProtocolFeatureActivationExtension>): ProtocolFeatureActivationExtension {
    const message = createBaseProtocolFeatureActivationExtension();
    message.protocolFeatures = object.protocolFeatures?.map((e) => e) || [];
    return message;
  },
};

function createBaseProducerScheduleChangeExtension(): ProducerScheduleChangeExtension {
  return { producerSchedule: undefined };
}

export const ProducerScheduleChangeExtension: MessageFns<ProducerScheduleChangeExtension> = {
  encode(message: ProducerScheduleChangeExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.producerSchedule !== undefined) {
      ProducerAuthoritySchedule.encode(message.producerSchedule, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProducerScheduleChangeExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProducerScheduleChangeExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.producerSchedule = ProducerAuthoritySchedule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProducerScheduleChangeExtension {
    return {
      producerSchedule: isSet(object.producerSchedule)
        ? ProducerAuthoritySchedule.fromJSON(object.producerSchedule)
        : undefined,
    };
  },

  toJSON(message: ProducerScheduleChangeExtension): unknown {
    const obj: any = {};
    if (message.producerSchedule !== undefined) {
      obj.producerSchedule = ProducerAuthoritySchedule.toJSON(message.producerSchedule);
    }
    return obj;
  },

  create(base?: DeepPartial<ProducerScheduleChangeExtension>): ProducerScheduleChangeExtension {
    return ProducerScheduleChangeExtension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProducerScheduleChangeExtension>): ProducerScheduleChangeExtension {
    const message = createBaseProducerScheduleChangeExtension();
    message.producerSchedule = (object.producerSchedule !== undefined && object.producerSchedule !== null)
      ? ProducerAuthoritySchedule.fromPartial(object.producerSchedule)
      : undefined;
    return message;
  },
};

function createBaseTransactionEvent(): TransactionEvent {
  return {
    id: "",
    blockId: "",
    blockNum: 0,
    irreversible: false,
    internalAddition: undefined,
    addition: undefined,
    execution: undefined,
    dtrxScheduling: undefined,
    dtrxCancellation: undefined,
  };
}

export const TransactionEvent: MessageFns<TransactionEvent> = {
  encode(message: TransactionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blockId !== "") {
      writer.uint32(18).string(message.blockId);
    }
    if (message.blockNum !== 0) {
      writer.uint32(24).uint32(message.blockNum);
    }
    if (message.irreversible !== false) {
      writer.uint32(32).bool(message.irreversible);
    }
    if (message.internalAddition !== undefined) {
      TransactionEvent_AddedInternally.encode(message.internalAddition, writer.uint32(42).fork()).join();
    }
    if (message.addition !== undefined) {
      TransactionEvent_Added.encode(message.addition, writer.uint32(50).fork()).join();
    }
    if (message.execution !== undefined) {
      TransactionEvent_Executed.encode(message.execution, writer.uint32(58).fork()).join();
    }
    if (message.dtrxScheduling !== undefined) {
      TransactionEvent_DtrxScheduled.encode(message.dtrxScheduling, writer.uint32(66).fork()).join();
    }
    if (message.dtrxCancellation !== undefined) {
      TransactionEvent_DtrxCanceled.encode(message.dtrxCancellation, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockNum = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.irreversible = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.internalAddition = TransactionEvent_AddedInternally.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.addition = TransactionEvent_Added.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.execution = TransactionEvent_Executed.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dtrxScheduling = TransactionEvent_DtrxScheduled.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dtrxCancellation = TransactionEvent_DtrxCanceled.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blockId: isSet(object.blockId) ? globalThis.String(object.blockId) : "",
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
      irreversible: isSet(object.irreversible) ? globalThis.Boolean(object.irreversible) : false,
      internalAddition: isSet(object.internalAddition)
        ? TransactionEvent_AddedInternally.fromJSON(object.internalAddition)
        : undefined,
      addition: isSet(object.addition) ? TransactionEvent_Added.fromJSON(object.addition) : undefined,
      execution: isSet(object.execution) ? TransactionEvent_Executed.fromJSON(object.execution) : undefined,
      dtrxScheduling: isSet(object.dtrxScheduling)
        ? TransactionEvent_DtrxScheduled.fromJSON(object.dtrxScheduling)
        : undefined,
      dtrxCancellation: isSet(object.dtrxCancellation)
        ? TransactionEvent_DtrxCanceled.fromJSON(object.dtrxCancellation)
        : undefined,
    };
  },

  toJSON(message: TransactionEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blockId !== "") {
      obj.blockId = message.blockId;
    }
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    if (message.irreversible !== false) {
      obj.irreversible = message.irreversible;
    }
    if (message.internalAddition !== undefined) {
      obj.internalAddition = TransactionEvent_AddedInternally.toJSON(message.internalAddition);
    }
    if (message.addition !== undefined) {
      obj.addition = TransactionEvent_Added.toJSON(message.addition);
    }
    if (message.execution !== undefined) {
      obj.execution = TransactionEvent_Executed.toJSON(message.execution);
    }
    if (message.dtrxScheduling !== undefined) {
      obj.dtrxScheduling = TransactionEvent_DtrxScheduled.toJSON(message.dtrxScheduling);
    }
    if (message.dtrxCancellation !== undefined) {
      obj.dtrxCancellation = TransactionEvent_DtrxCanceled.toJSON(message.dtrxCancellation);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionEvent>): TransactionEvent {
    return TransactionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionEvent>): TransactionEvent {
    const message = createBaseTransactionEvent();
    message.id = object.id ?? "";
    message.blockId = object.blockId ?? "";
    message.blockNum = object.blockNum ?? 0;
    message.irreversible = object.irreversible ?? false;
    message.internalAddition = (object.internalAddition !== undefined && object.internalAddition !== null)
      ? TransactionEvent_AddedInternally.fromPartial(object.internalAddition)
      : undefined;
    message.addition = (object.addition !== undefined && object.addition !== null)
      ? TransactionEvent_Added.fromPartial(object.addition)
      : undefined;
    message.execution = (object.execution !== undefined && object.execution !== null)
      ? TransactionEvent_Executed.fromPartial(object.execution)
      : undefined;
    message.dtrxScheduling = (object.dtrxScheduling !== undefined && object.dtrxScheduling !== null)
      ? TransactionEvent_DtrxScheduled.fromPartial(object.dtrxScheduling)
      : undefined;
    message.dtrxCancellation = (object.dtrxCancellation !== undefined && object.dtrxCancellation !== null)
      ? TransactionEvent_DtrxCanceled.fromPartial(object.dtrxCancellation)
      : undefined;
    return message;
  },
};

function createBaseTransactionEvent_AddedInternally(): TransactionEvent_AddedInternally {
  return { transaction: undefined };
}

export const TransactionEvent_AddedInternally: MessageFns<TransactionEvent_AddedInternally> = {
  encode(message: TransactionEvent_AddedInternally, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      SignedTransaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent_AddedInternally {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent_AddedInternally();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transaction = SignedTransaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent_AddedInternally {
    return { transaction: isSet(object.transaction) ? SignedTransaction.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: TransactionEvent_AddedInternally): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = SignedTransaction.toJSON(message.transaction);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionEvent_AddedInternally>): TransactionEvent_AddedInternally {
    return TransactionEvent_AddedInternally.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionEvent_AddedInternally>): TransactionEvent_AddedInternally {
    const message = createBaseTransactionEvent_AddedInternally();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? SignedTransaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseTransactionEvent_Added(): TransactionEvent_Added {
  return { receipt: undefined, transaction: undefined, publicKeys: undefined };
}

export const TransactionEvent_Added: MessageFns<TransactionEvent_Added> = {
  encode(message: TransactionEvent_Added, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receipt !== undefined) {
      TransactionReceipt.encode(message.receipt, writer.uint32(10).fork()).join();
    }
    if (message.transaction !== undefined) {
      SignedTransaction.encode(message.transaction, writer.uint32(18).fork()).join();
    }
    if (message.publicKeys !== undefined) {
      PublicKeys.encode(message.publicKeys, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent_Added {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent_Added();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.receipt = TransactionReceipt.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = SignedTransaction.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKeys = PublicKeys.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent_Added {
    return {
      receipt: isSet(object.receipt) ? TransactionReceipt.fromJSON(object.receipt) : undefined,
      transaction: isSet(object.transaction) ? SignedTransaction.fromJSON(object.transaction) : undefined,
      publicKeys: isSet(object.publicKeys) ? PublicKeys.fromJSON(object.publicKeys) : undefined,
    };
  },

  toJSON(message: TransactionEvent_Added): unknown {
    const obj: any = {};
    if (message.receipt !== undefined) {
      obj.receipt = TransactionReceipt.toJSON(message.receipt);
    }
    if (message.transaction !== undefined) {
      obj.transaction = SignedTransaction.toJSON(message.transaction);
    }
    if (message.publicKeys !== undefined) {
      obj.publicKeys = PublicKeys.toJSON(message.publicKeys);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionEvent_Added>): TransactionEvent_Added {
    return TransactionEvent_Added.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionEvent_Added>): TransactionEvent_Added {
    const message = createBaseTransactionEvent_Added();
    message.receipt = (object.receipt !== undefined && object.receipt !== null)
      ? TransactionReceipt.fromPartial(object.receipt)
      : undefined;
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? SignedTransaction.fromPartial(object.transaction)
      : undefined;
    message.publicKeys = (object.publicKeys !== undefined && object.publicKeys !== null)
      ? PublicKeys.fromPartial(object.publicKeys)
      : undefined;
    return message;
  },
};

function createBaseTransactionEvent_Executed(): TransactionEvent_Executed {
  return { trace: undefined, blockHeader: undefined };
}

export const TransactionEvent_Executed: MessageFns<TransactionEvent_Executed> = {
  encode(message: TransactionEvent_Executed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace !== undefined) {
      TransactionTrace.encode(message.trace, writer.uint32(10).fork()).join();
    }
    if (message.blockHeader !== undefined) {
      BlockHeader.encode(message.blockHeader, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent_Executed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent_Executed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trace = TransactionTrace.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockHeader = BlockHeader.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent_Executed {
    return {
      trace: isSet(object.trace) ? TransactionTrace.fromJSON(object.trace) : undefined,
      blockHeader: isSet(object.blockHeader) ? BlockHeader.fromJSON(object.blockHeader) : undefined,
    };
  },

  toJSON(message: TransactionEvent_Executed): unknown {
    const obj: any = {};
    if (message.trace !== undefined) {
      obj.trace = TransactionTrace.toJSON(message.trace);
    }
    if (message.blockHeader !== undefined) {
      obj.blockHeader = BlockHeader.toJSON(message.blockHeader);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionEvent_Executed>): TransactionEvent_Executed {
    return TransactionEvent_Executed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionEvent_Executed>): TransactionEvent_Executed {
    const message = createBaseTransactionEvent_Executed();
    message.trace = (object.trace !== undefined && object.trace !== null)
      ? TransactionTrace.fromPartial(object.trace)
      : undefined;
    message.blockHeader = (object.blockHeader !== undefined && object.blockHeader !== null)
      ? BlockHeader.fromPartial(object.blockHeader)
      : undefined;
    return message;
  },
};

function createBaseTransactionEvent_DtrxScheduled(): TransactionEvent_DtrxScheduled {
  return { createdBy: undefined, transaction: undefined };
}

export const TransactionEvent_DtrxScheduled: MessageFns<TransactionEvent_DtrxScheduled> = {
  encode(message: TransactionEvent_DtrxScheduled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createdBy !== undefined) {
      ExtDTrxOp.encode(message.createdBy, writer.uint32(10).fork()).join();
    }
    if (message.transaction !== undefined) {
      SignedTransaction.encode(message.transaction, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent_DtrxScheduled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent_DtrxScheduled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createdBy = ExtDTrxOp.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = SignedTransaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent_DtrxScheduled {
    return {
      createdBy: isSet(object.createdBy) ? ExtDTrxOp.fromJSON(object.createdBy) : undefined,
      transaction: isSet(object.transaction) ? SignedTransaction.fromJSON(object.transaction) : undefined,
    };
  },

  toJSON(message: TransactionEvent_DtrxScheduled): unknown {
    const obj: any = {};
    if (message.createdBy !== undefined) {
      obj.createdBy = ExtDTrxOp.toJSON(message.createdBy);
    }
    if (message.transaction !== undefined) {
      obj.transaction = SignedTransaction.toJSON(message.transaction);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionEvent_DtrxScheduled>): TransactionEvent_DtrxScheduled {
    return TransactionEvent_DtrxScheduled.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionEvent_DtrxScheduled>): TransactionEvent_DtrxScheduled {
    const message = createBaseTransactionEvent_DtrxScheduled();
    message.createdBy = (object.createdBy !== undefined && object.createdBy !== null)
      ? ExtDTrxOp.fromPartial(object.createdBy)
      : undefined;
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? SignedTransaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseTransactionEvent_DtrxCanceled(): TransactionEvent_DtrxCanceled {
  return { canceledBy: undefined };
}

export const TransactionEvent_DtrxCanceled: MessageFns<TransactionEvent_DtrxCanceled> = {
  encode(message: TransactionEvent_DtrxCanceled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canceledBy !== undefined) {
      ExtDTrxOp.encode(message.canceledBy, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent_DtrxCanceled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent_DtrxCanceled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.canceledBy = ExtDTrxOp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent_DtrxCanceled {
    return { canceledBy: isSet(object.canceledBy) ? ExtDTrxOp.fromJSON(object.canceledBy) : undefined };
  },

  toJSON(message: TransactionEvent_DtrxCanceled): unknown {
    const obj: any = {};
    if (message.canceledBy !== undefined) {
      obj.canceledBy = ExtDTrxOp.toJSON(message.canceledBy);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionEvent_DtrxCanceled>): TransactionEvent_DtrxCanceled {
    return TransactionEvent_DtrxCanceled.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionEvent_DtrxCanceled>): TransactionEvent_DtrxCanceled {
    const message = createBaseTransactionEvent_DtrxCanceled();
    message.canceledBy = (object.canceledBy !== undefined && object.canceledBy !== null)
      ? ExtDTrxOp.fromPartial(object.canceledBy)
      : undefined;
    return message;
  },
};

function createBasePublicKeys(): PublicKeys {
  return { publicKeys: [] };
}

export const PublicKeys: MessageFns<PublicKeys> = {
  encode(message: PublicKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.publicKeys) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.publicKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicKeys {
    return {
      publicKeys: globalThis.Array.isArray(object?.publicKeys)
        ? object.publicKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PublicKeys): unknown {
    const obj: any = {};
    if (message.publicKeys?.length) {
      obj.publicKeys = message.publicKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<PublicKeys>): PublicKeys {
    return PublicKeys.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublicKeys>): PublicKeys {
    const message = createBasePublicKeys();
    message.publicKeys = object.publicKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseTransactionLifecycle(): TransactionLifecycle {
  return {
    id: "",
    transactionStatus: 0,
    transactionReceipt: undefined,
    transaction: undefined,
    publicKeys: [],
    executionTrace: undefined,
    executionBlockHeader: undefined,
    createdBy: undefined,
    canceledBy: undefined,
    creationIrreversible: false,
    executionIrreversible: false,
    cancelationIrreversible: false,
  };
}

export const TransactionLifecycle: MessageFns<TransactionLifecycle> = {
  encode(message: TransactionLifecycle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transactionStatus !== 0) {
      writer.uint32(16).int32(message.transactionStatus);
    }
    if (message.transactionReceipt !== undefined) {
      TransactionReceipt.encode(message.transactionReceipt, writer.uint32(290).fork()).join();
    }
    if (message.transaction !== undefined) {
      SignedTransaction.encode(message.transaction, writer.uint32(82).fork()).join();
    }
    for (const v of message.publicKeys) {
      writer.uint32(154).string(v!);
    }
    if (message.executionTrace !== undefined) {
      TransactionTrace.encode(message.executionTrace, writer.uint32(90).fork()).join();
    }
    if (message.executionBlockHeader !== undefined) {
      BlockHeader.encode(message.executionBlockHeader, writer.uint32(98).fork()).join();
    }
    if (message.createdBy !== undefined) {
      ExtDTrxOp.encode(message.createdBy, writer.uint32(162).fork()).join();
    }
    if (message.canceledBy !== undefined) {
      ExtDTrxOp.encode(message.canceledBy, writer.uint32(170).fork()).join();
    }
    if (message.creationIrreversible !== false) {
      writer.uint32(264).bool(message.creationIrreversible);
    }
    if (message.executionIrreversible !== false) {
      writer.uint32(272).bool(message.executionIrreversible);
    }
    if (message.cancelationIrreversible !== false) {
      writer.uint32(280).bool(message.cancelationIrreversible);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionLifecycle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionLifecycle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.transactionStatus = reader.int32() as any;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.transactionReceipt = TransactionReceipt.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.transaction = SignedTransaction.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.publicKeys.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.executionTrace = TransactionTrace.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.executionBlockHeader = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.createdBy = ExtDTrxOp.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.canceledBy = ExtDTrxOp.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.creationIrreversible = reader.bool();
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.executionIrreversible = reader.bool();
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.cancelationIrreversible = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionLifecycle {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transactionStatus: isSet(object.transactionStatus) ? transactionStatusFromJSON(object.transactionStatus) : 0,
      transactionReceipt: isSet(object.transactionReceipt)
        ? TransactionReceipt.fromJSON(object.transactionReceipt)
        : undefined,
      transaction: isSet(object.transaction) ? SignedTransaction.fromJSON(object.transaction) : undefined,
      publicKeys: globalThis.Array.isArray(object?.publicKeys)
        ? object.publicKeys.map((e: any) => globalThis.String(e))
        : [],
      executionTrace: isSet(object.executionTrace) ? TransactionTrace.fromJSON(object.executionTrace) : undefined,
      executionBlockHeader: isSet(object.executionBlockHeader)
        ? BlockHeader.fromJSON(object.executionBlockHeader)
        : undefined,
      createdBy: isSet(object.createdBy) ? ExtDTrxOp.fromJSON(object.createdBy) : undefined,
      canceledBy: isSet(object.canceledBy) ? ExtDTrxOp.fromJSON(object.canceledBy) : undefined,
      creationIrreversible: isSet(object.creationIrreversible)
        ? globalThis.Boolean(object.creationIrreversible)
        : false,
      executionIrreversible: isSet(object.executionIrreversible)
        ? globalThis.Boolean(object.executionIrreversible)
        : false,
      cancelationIrreversible: isSet(object.cancelationIrreversible)
        ? globalThis.Boolean(object.cancelationIrreversible)
        : false,
    };
  },

  toJSON(message: TransactionLifecycle): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transactionStatus !== 0) {
      obj.transactionStatus = transactionStatusToJSON(message.transactionStatus);
    }
    if (message.transactionReceipt !== undefined) {
      obj.transactionReceipt = TransactionReceipt.toJSON(message.transactionReceipt);
    }
    if (message.transaction !== undefined) {
      obj.transaction = SignedTransaction.toJSON(message.transaction);
    }
    if (message.publicKeys?.length) {
      obj.publicKeys = message.publicKeys;
    }
    if (message.executionTrace !== undefined) {
      obj.executionTrace = TransactionTrace.toJSON(message.executionTrace);
    }
    if (message.executionBlockHeader !== undefined) {
      obj.executionBlockHeader = BlockHeader.toJSON(message.executionBlockHeader);
    }
    if (message.createdBy !== undefined) {
      obj.createdBy = ExtDTrxOp.toJSON(message.createdBy);
    }
    if (message.canceledBy !== undefined) {
      obj.canceledBy = ExtDTrxOp.toJSON(message.canceledBy);
    }
    if (message.creationIrreversible !== false) {
      obj.creationIrreversible = message.creationIrreversible;
    }
    if (message.executionIrreversible !== false) {
      obj.executionIrreversible = message.executionIrreversible;
    }
    if (message.cancelationIrreversible !== false) {
      obj.cancelationIrreversible = message.cancelationIrreversible;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionLifecycle>): TransactionLifecycle {
    return TransactionLifecycle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionLifecycle>): TransactionLifecycle {
    const message = createBaseTransactionLifecycle();
    message.id = object.id ?? "";
    message.transactionStatus = object.transactionStatus ?? 0;
    message.transactionReceipt = (object.transactionReceipt !== undefined && object.transactionReceipt !== null)
      ? TransactionReceipt.fromPartial(object.transactionReceipt)
      : undefined;
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? SignedTransaction.fromPartial(object.transaction)
      : undefined;
    message.publicKeys = object.publicKeys?.map((e) => e) || [];
    message.executionTrace = (object.executionTrace !== undefined && object.executionTrace !== null)
      ? TransactionTrace.fromPartial(object.executionTrace)
      : undefined;
    message.executionBlockHeader = (object.executionBlockHeader !== undefined && object.executionBlockHeader !== null)
      ? BlockHeader.fromPartial(object.executionBlockHeader)
      : undefined;
    message.createdBy = (object.createdBy !== undefined && object.createdBy !== null)
      ? ExtDTrxOp.fromPartial(object.createdBy)
      : undefined;
    message.canceledBy = (object.canceledBy !== undefined && object.canceledBy !== null)
      ? ExtDTrxOp.fromPartial(object.canceledBy)
      : undefined;
    message.creationIrreversible = object.creationIrreversible ?? false;
    message.executionIrreversible = object.executionIrreversible ?? false;
    message.cancelationIrreversible = object.cancelationIrreversible ?? false;
    return message;
  },
};

function createBaseSignedTransaction(): SignedTransaction {
  return { transaction: undefined, signatures: [], contextFreeData: [] };
}

export const SignedTransaction: MessageFns<SignedTransaction> = {
  encode(message: SignedTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    for (const v of message.signatures) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.contextFreeData) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signatures.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contextFreeData.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedTransaction {
    return {
      transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined,
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => globalThis.String(e))
        : [],
      contextFreeData: globalThis.Array.isArray(object?.contextFreeData)
        ? object.contextFreeData.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: SignedTransaction): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures;
    }
    if (message.contextFreeData?.length) {
      obj.contextFreeData = message.contextFreeData.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SignedTransaction>): SignedTransaction {
    return SignedTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedTransaction>): SignedTransaction {
    const message = createBaseSignedTransaction();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    message.signatures = object.signatures?.map((e) => e) || [];
    message.contextFreeData = object.contextFreeData?.map((e) => e) || [];
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return { header: undefined, contextFreeActions: [], actions: [], extensions: [] };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      TransactionHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    for (const v of message.contextFreeActions) {
      Action.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.actions) {
      Action.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.extensions) {
      Extension.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = TransactionHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contextFreeActions.push(Action.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actions.push(Action.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.extensions.push(Extension.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      header: isSet(object.header) ? TransactionHeader.fromJSON(object.header) : undefined,
      contextFreeActions: globalThis.Array.isArray(object?.contextFreeActions)
        ? object.contextFreeActions.map((e: any) => Action.fromJSON(e))
        : [],
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => Action.fromJSON(e)) : [],
      extensions: globalThis.Array.isArray(object?.extensions)
        ? object.extensions.map((e: any) => Extension.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = TransactionHeader.toJSON(message.header);
    }
    if (message.contextFreeActions?.length) {
      obj.contextFreeActions = message.contextFreeActions.map((e) => Action.toJSON(e));
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Action.toJSON(e));
    }
    if (message.extensions?.length) {
      obj.extensions = message.extensions.map((e) => Extension.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Transaction>): Transaction {
    return Transaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transaction>): Transaction {
    const message = createBaseTransaction();
    message.header = (object.header !== undefined && object.header !== null)
      ? TransactionHeader.fromPartial(object.header)
      : undefined;
    message.contextFreeActions = object.contextFreeActions?.map((e) => Action.fromPartial(e)) || [];
    message.actions = object.actions?.map((e) => Action.fromPartial(e)) || [];
    message.extensions = object.extensions?.map((e) => Extension.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionHeader(): TransactionHeader {
  return {
    expiration: undefined,
    refBlockNum: 0,
    refBlockPrefix: 0,
    maxNetUsageWords: 0,
    maxCpuUsageMs: 0,
    delaySec: 0,
  };
}

export const TransactionHeader: MessageFns<TransactionHeader> = {
  encode(message: TransactionHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expiration !== undefined) {
      Timestamp.encode(toTimestamp(message.expiration), writer.uint32(10).fork()).join();
    }
    if (message.refBlockNum !== 0) {
      writer.uint32(16).uint32(message.refBlockNum);
    }
    if (message.refBlockPrefix !== 0) {
      writer.uint32(24).uint32(message.refBlockPrefix);
    }
    if (message.maxNetUsageWords !== 0) {
      writer.uint32(32).uint32(message.maxNetUsageWords);
    }
    if (message.maxCpuUsageMs !== 0) {
      writer.uint32(40).uint32(message.maxCpuUsageMs);
    }
    if (message.delaySec !== 0) {
      writer.uint32(48).uint32(message.delaySec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expiration = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.refBlockNum = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.refBlockPrefix = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxNetUsageWords = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxCpuUsageMs = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.delaySec = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionHeader {
    return {
      expiration: isSet(object.expiration) ? fromJsonTimestamp(object.expiration) : undefined,
      refBlockNum: isSet(object.refBlockNum) ? globalThis.Number(object.refBlockNum) : 0,
      refBlockPrefix: isSet(object.refBlockPrefix) ? globalThis.Number(object.refBlockPrefix) : 0,
      maxNetUsageWords: isSet(object.maxNetUsageWords) ? globalThis.Number(object.maxNetUsageWords) : 0,
      maxCpuUsageMs: isSet(object.maxCpuUsageMs) ? globalThis.Number(object.maxCpuUsageMs) : 0,
      delaySec: isSet(object.delaySec) ? globalThis.Number(object.delaySec) : 0,
    };
  },

  toJSON(message: TransactionHeader): unknown {
    const obj: any = {};
    if (message.expiration !== undefined) {
      obj.expiration = message.expiration.toISOString();
    }
    if (message.refBlockNum !== 0) {
      obj.refBlockNum = Math.round(message.refBlockNum);
    }
    if (message.refBlockPrefix !== 0) {
      obj.refBlockPrefix = Math.round(message.refBlockPrefix);
    }
    if (message.maxNetUsageWords !== 0) {
      obj.maxNetUsageWords = Math.round(message.maxNetUsageWords);
    }
    if (message.maxCpuUsageMs !== 0) {
      obj.maxCpuUsageMs = Math.round(message.maxCpuUsageMs);
    }
    if (message.delaySec !== 0) {
      obj.delaySec = Math.round(message.delaySec);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionHeader>): TransactionHeader {
    return TransactionHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionHeader>): TransactionHeader {
    const message = createBaseTransactionHeader();
    message.expiration = object.expiration ?? undefined;
    message.refBlockNum = object.refBlockNum ?? 0;
    message.refBlockPrefix = object.refBlockPrefix ?? 0;
    message.maxNetUsageWords = object.maxNetUsageWords ?? 0;
    message.maxCpuUsageMs = object.maxCpuUsageMs ?? 0;
    message.delaySec = object.delaySec ?? 0;
    return message;
  },
};

function createBaseTransactionTrace(): TransactionTrace {
  return {
    id: "",
    blockNum: 0,
    index: 0,
    blockTime: undefined,
    producerBlockId: "",
    receipt: undefined,
    elapsed: 0,
    netUsage: 0,
    scheduled: false,
    actionTraces: [],
    failedDtrxTrace: undefined,
    exception: undefined,
    errorCode: 0,
    dbOps: [],
    dtrxOps: [],
    featureOps: [],
    permOps: [],
    ramOps: [],
    ramCorrectionOps: [],
    rlimitOps: [],
    tableOps: [],
    creationTree: [],
  };
}

export const TransactionTrace: MessageFns<TransactionTrace> = {
  encode(message: TransactionTrace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blockNum !== 0) {
      writer.uint32(16).uint64(message.blockNum);
    }
    if (message.index !== 0) {
      writer.uint32(208).uint64(message.index);
    }
    if (message.blockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.blockTime), writer.uint32(26).fork()).join();
    }
    if (message.producerBlockId !== "") {
      writer.uint32(34).string(message.producerBlockId);
    }
    if (message.receipt !== undefined) {
      TransactionReceiptHeader.encode(message.receipt, writer.uint32(42).fork()).join();
    }
    if (message.elapsed !== 0) {
      writer.uint32(48).int64(message.elapsed);
    }
    if (message.netUsage !== 0) {
      writer.uint32(56).uint64(message.netUsage);
    }
    if (message.scheduled !== false) {
      writer.uint32(64).bool(message.scheduled);
    }
    for (const v of message.actionTraces) {
      ActionTrace.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.failedDtrxTrace !== undefined) {
      TransactionTrace.encode(message.failedDtrxTrace, writer.uint32(82).fork()).join();
    }
    if (message.exception !== undefined) {
      Exception.encode(message.exception, writer.uint32(122).fork()).join();
    }
    if (message.errorCode !== 0) {
      writer.uint32(128).uint64(message.errorCode);
    }
    for (const v of message.dbOps) {
      DBOp.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.dtrxOps) {
      DTrxOp.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.featureOps) {
      FeatureOp.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.permOps) {
      PermOp.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.ramOps) {
      RAMOp.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.ramCorrectionOps) {
      RAMCorrectionOp.encode(v!, writer.uint32(178).fork()).join();
    }
    for (const v of message.rlimitOps) {
      RlimitOp.encode(v!, writer.uint32(186).fork()).join();
    }
    for (const v of message.tableOps) {
      TableOp.encode(v!, writer.uint32(194).fork()).join();
    }
    for (const v of message.creationTree) {
      CreationFlatNode.encode(v!, writer.uint32(202).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionTrace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockNum = longToNumber(reader.uint64());
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.index = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.producerBlockId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.receipt = TransactionReceiptHeader.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.elapsed = longToNumber(reader.int64());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.netUsage = longToNumber(reader.uint64());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.scheduled = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.actionTraces.push(ActionTrace.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.failedDtrxTrace = TransactionTrace.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.exception = Exception.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.errorCode = longToNumber(reader.uint64());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.dbOps.push(DBOp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.dtrxOps.push(DTrxOp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.featureOps.push(FeatureOp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.permOps.push(PermOp.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.ramOps.push(RAMOp.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.ramCorrectionOps.push(RAMCorrectionOp.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.rlimitOps.push(RlimitOp.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.tableOps.push(TableOp.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.creationTree.push(CreationFlatNode.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionTrace {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      blockTime: isSet(object.blockTime) ? fromJsonTimestamp(object.blockTime) : undefined,
      producerBlockId: isSet(object.producerBlockId) ? globalThis.String(object.producerBlockId) : "",
      receipt: isSet(object.receipt) ? TransactionReceiptHeader.fromJSON(object.receipt) : undefined,
      elapsed: isSet(object.elapsed) ? globalThis.Number(object.elapsed) : 0,
      netUsage: isSet(object.netUsage) ? globalThis.Number(object.netUsage) : 0,
      scheduled: isSet(object.scheduled) ? globalThis.Boolean(object.scheduled) : false,
      actionTraces: globalThis.Array.isArray(object?.actionTraces)
        ? object.actionTraces.map((e: any) => ActionTrace.fromJSON(e))
        : [],
      failedDtrxTrace: isSet(object.failedDtrxTrace) ? TransactionTrace.fromJSON(object.failedDtrxTrace) : undefined,
      exception: isSet(object.exception) ? Exception.fromJSON(object.exception) : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.Number(object.errorCode) : 0,
      dbOps: globalThis.Array.isArray(object?.dbOps) ? object.dbOps.map((e: any) => DBOp.fromJSON(e)) : [],
      dtrxOps: globalThis.Array.isArray(object?.dtrxOps) ? object.dtrxOps.map((e: any) => DTrxOp.fromJSON(e)) : [],
      featureOps: globalThis.Array.isArray(object?.featureOps)
        ? object.featureOps.map((e: any) => FeatureOp.fromJSON(e))
        : [],
      permOps: globalThis.Array.isArray(object?.permOps) ? object.permOps.map((e: any) => PermOp.fromJSON(e)) : [],
      ramOps: globalThis.Array.isArray(object?.ramOps) ? object.ramOps.map((e: any) => RAMOp.fromJSON(e)) : [],
      ramCorrectionOps: globalThis.Array.isArray(object?.ramCorrectionOps)
        ? object.ramCorrectionOps.map((e: any) => RAMCorrectionOp.fromJSON(e))
        : [],
      rlimitOps: globalThis.Array.isArray(object?.rlimitOps)
        ? object.rlimitOps.map((e: any) => RlimitOp.fromJSON(e))
        : [],
      tableOps: globalThis.Array.isArray(object?.tableOps) ? object.tableOps.map((e: any) => TableOp.fromJSON(e)) : [],
      creationTree: globalThis.Array.isArray(object?.creationTree)
        ? object.creationTree.map((e: any) => CreationFlatNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionTrace): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.blockTime !== undefined) {
      obj.blockTime = message.blockTime.toISOString();
    }
    if (message.producerBlockId !== "") {
      obj.producerBlockId = message.producerBlockId;
    }
    if (message.receipt !== undefined) {
      obj.receipt = TransactionReceiptHeader.toJSON(message.receipt);
    }
    if (message.elapsed !== 0) {
      obj.elapsed = Math.round(message.elapsed);
    }
    if (message.netUsage !== 0) {
      obj.netUsage = Math.round(message.netUsage);
    }
    if (message.scheduled !== false) {
      obj.scheduled = message.scheduled;
    }
    if (message.actionTraces?.length) {
      obj.actionTraces = message.actionTraces.map((e) => ActionTrace.toJSON(e));
    }
    if (message.failedDtrxTrace !== undefined) {
      obj.failedDtrxTrace = TransactionTrace.toJSON(message.failedDtrxTrace);
    }
    if (message.exception !== undefined) {
      obj.exception = Exception.toJSON(message.exception);
    }
    if (message.errorCode !== 0) {
      obj.errorCode = Math.round(message.errorCode);
    }
    if (message.dbOps?.length) {
      obj.dbOps = message.dbOps.map((e) => DBOp.toJSON(e));
    }
    if (message.dtrxOps?.length) {
      obj.dtrxOps = message.dtrxOps.map((e) => DTrxOp.toJSON(e));
    }
    if (message.featureOps?.length) {
      obj.featureOps = message.featureOps.map((e) => FeatureOp.toJSON(e));
    }
    if (message.permOps?.length) {
      obj.permOps = message.permOps.map((e) => PermOp.toJSON(e));
    }
    if (message.ramOps?.length) {
      obj.ramOps = message.ramOps.map((e) => RAMOp.toJSON(e));
    }
    if (message.ramCorrectionOps?.length) {
      obj.ramCorrectionOps = message.ramCorrectionOps.map((e) => RAMCorrectionOp.toJSON(e));
    }
    if (message.rlimitOps?.length) {
      obj.rlimitOps = message.rlimitOps.map((e) => RlimitOp.toJSON(e));
    }
    if (message.tableOps?.length) {
      obj.tableOps = message.tableOps.map((e) => TableOp.toJSON(e));
    }
    if (message.creationTree?.length) {
      obj.creationTree = message.creationTree.map((e) => CreationFlatNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionTrace>): TransactionTrace {
    return TransactionTrace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionTrace>): TransactionTrace {
    const message = createBaseTransactionTrace();
    message.id = object.id ?? "";
    message.blockNum = object.blockNum ?? 0;
    message.index = object.index ?? 0;
    message.blockTime = object.blockTime ?? undefined;
    message.producerBlockId = object.producerBlockId ?? "";
    message.receipt = (object.receipt !== undefined && object.receipt !== null)
      ? TransactionReceiptHeader.fromPartial(object.receipt)
      : undefined;
    message.elapsed = object.elapsed ?? 0;
    message.netUsage = object.netUsage ?? 0;
    message.scheduled = object.scheduled ?? false;
    message.actionTraces = object.actionTraces?.map((e) => ActionTrace.fromPartial(e)) || [];
    message.failedDtrxTrace = (object.failedDtrxTrace !== undefined && object.failedDtrxTrace !== null)
      ? TransactionTrace.fromPartial(object.failedDtrxTrace)
      : undefined;
    message.exception = (object.exception !== undefined && object.exception !== null)
      ? Exception.fromPartial(object.exception)
      : undefined;
    message.errorCode = object.errorCode ?? 0;
    message.dbOps = object.dbOps?.map((e) => DBOp.fromPartial(e)) || [];
    message.dtrxOps = object.dtrxOps?.map((e) => DTrxOp.fromPartial(e)) || [];
    message.featureOps = object.featureOps?.map((e) => FeatureOp.fromPartial(e)) || [];
    message.permOps = object.permOps?.map((e) => PermOp.fromPartial(e)) || [];
    message.ramOps = object.ramOps?.map((e) => RAMOp.fromPartial(e)) || [];
    message.ramCorrectionOps = object.ramCorrectionOps?.map((e) => RAMCorrectionOp.fromPartial(e)) || [];
    message.rlimitOps = object.rlimitOps?.map((e) => RlimitOp.fromPartial(e)) || [];
    message.tableOps = object.tableOps?.map((e) => TableOp.fromPartial(e)) || [];
    message.creationTree = object.creationTree?.map((e) => CreationFlatNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionReceiptHeader(): TransactionReceiptHeader {
  return { status: 0, cpuUsageMicroSeconds: 0, netUsageWords: 0 };
}

export const TransactionReceiptHeader: MessageFns<TransactionReceiptHeader> = {
  encode(message: TransactionReceiptHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.cpuUsageMicroSeconds !== 0) {
      writer.uint32(16).uint32(message.cpuUsageMicroSeconds);
    }
    if (message.netUsageWords !== 0) {
      writer.uint32(24).uint32(message.netUsageWords);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionReceiptHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionReceiptHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cpuUsageMicroSeconds = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.netUsageWords = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionReceiptHeader {
    return {
      status: isSet(object.status) ? transactionStatusFromJSON(object.status) : 0,
      cpuUsageMicroSeconds: isSet(object.cpuUsageMicroSeconds) ? globalThis.Number(object.cpuUsageMicroSeconds) : 0,
      netUsageWords: isSet(object.netUsageWords) ? globalThis.Number(object.netUsageWords) : 0,
    };
  },

  toJSON(message: TransactionReceiptHeader): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = transactionStatusToJSON(message.status);
    }
    if (message.cpuUsageMicroSeconds !== 0) {
      obj.cpuUsageMicroSeconds = Math.round(message.cpuUsageMicroSeconds);
    }
    if (message.netUsageWords !== 0) {
      obj.netUsageWords = Math.round(message.netUsageWords);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionReceiptHeader>): TransactionReceiptHeader {
    return TransactionReceiptHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionReceiptHeader>): TransactionReceiptHeader {
    const message = createBaseTransactionReceiptHeader();
    message.status = object.status ?? 0;
    message.cpuUsageMicroSeconds = object.cpuUsageMicroSeconds ?? 0;
    message.netUsageWords = object.netUsageWords ?? 0;
    return message;
  },
};

function createBaseAction(): Action {
  return { account: "", name: "", authorization: [], jsonData: "", rawData: new Uint8Array(0) };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.authorization) {
      PermissionLevel.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.jsonData !== "") {
      writer.uint32(34).string(message.jsonData);
    }
    if (message.rawData.length !== 0) {
      writer.uint32(42).bytes(message.rawData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authorization.push(PermissionLevel.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.jsonData = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rawData = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      authorization: globalThis.Array.isArray(object?.authorization)
        ? object.authorization.map((e: any) => PermissionLevel.fromJSON(e))
        : [],
      jsonData: isSet(object.jsonData) ? globalThis.String(object.jsonData) : "",
      rawData: isSet(object.rawData) ? bytesFromBase64(object.rawData) : new Uint8Array(0),
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.authorization?.length) {
      obj.authorization = message.authorization.map((e) => PermissionLevel.toJSON(e));
    }
    if (message.jsonData !== "") {
      obj.jsonData = message.jsonData;
    }
    if (message.rawData.length !== 0) {
      obj.rawData = base64FromBytes(message.rawData);
    }
    return obj;
  },

  create(base?: DeepPartial<Action>): Action {
    return Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Action>): Action {
    const message = createBaseAction();
    message.account = object.account ?? "";
    message.name = object.name ?? "";
    message.authorization = object.authorization?.map((e) => PermissionLevel.fromPartial(e)) || [];
    message.jsonData = object.jsonData ?? "";
    message.rawData = object.rawData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseActionTrace(): ActionTrace {
  return {
    receiver: "",
    receipt: undefined,
    action: undefined,
    contextFree: false,
    elapsed: 0,
    console: "",
    transactionId: "",
    blockNum: 0,
    producerBlockId: "",
    blockTime: undefined,
    accountRamDeltas: [],
    rawReturnValue: new Uint8Array(0),
    jsonReturnValue: "",
    exception: undefined,
    errorCode: 0,
    actionOrdinal: 0,
    creatorActionOrdinal: 0,
    closestUnnotifiedAncestorActionOrdinal: 0,
    executionIndex: 0,
    filteringMatched: false,
    filteringMatchedSystemActionFilter: false,
  };
}

export const ActionTrace: MessageFns<ActionTrace> = {
  encode(message: ActionTrace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receiver !== "") {
      writer.uint32(90).string(message.receiver);
    }
    if (message.receipt !== undefined) {
      ActionReceipt.encode(message.receipt, writer.uint32(10).fork()).join();
    }
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(18).fork()).join();
    }
    if (message.contextFree !== false) {
      writer.uint32(24).bool(message.contextFree);
    }
    if (message.elapsed !== 0) {
      writer.uint32(32).int64(message.elapsed);
    }
    if (message.console !== "") {
      writer.uint32(42).string(message.console);
    }
    if (message.transactionId !== "") {
      writer.uint32(50).string(message.transactionId);
    }
    if (message.blockNum !== 0) {
      writer.uint32(56).uint64(message.blockNum);
    }
    if (message.producerBlockId !== "") {
      writer.uint32(66).string(message.producerBlockId);
    }
    if (message.blockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.blockTime), writer.uint32(74).fork()).join();
    }
    for (const v of message.accountRamDeltas) {
      AccountRAMDelta.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.rawReturnValue.length !== 0) {
      writer.uint32(330).bytes(message.rawReturnValue);
    }
    if (message.jsonReturnValue !== "") {
      writer.uint32(338).string(message.jsonReturnValue);
    }
    if (message.exception !== undefined) {
      Exception.encode(message.exception, writer.uint32(122).fork()).join();
    }
    if (message.errorCode !== 0) {
      writer.uint32(160).uint64(message.errorCode);
    }
    if (message.actionOrdinal !== 0) {
      writer.uint32(128).uint32(message.actionOrdinal);
    }
    if (message.creatorActionOrdinal !== 0) {
      writer.uint32(136).uint32(message.creatorActionOrdinal);
    }
    if (message.closestUnnotifiedAncestorActionOrdinal !== 0) {
      writer.uint32(144).uint32(message.closestUnnotifiedAncestorActionOrdinal);
    }
    if (message.executionIndex !== 0) {
      writer.uint32(152).uint32(message.executionIndex);
    }
    if (message.filteringMatched !== false) {
      writer.uint32(240).bool(message.filteringMatched);
    }
    if (message.filteringMatchedSystemActionFilter !== false) {
      writer.uint32(248).bool(message.filteringMatchedSystemActionFilter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionTrace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          if (tag !== 90) {
            break;
          }

          message.receiver = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.receipt = ActionReceipt.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextFree = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.elapsed = longToNumber(reader.int64());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.console = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.blockNum = longToNumber(reader.uint64());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.producerBlockId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.blockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.accountRamDeltas.push(AccountRAMDelta.decode(reader, reader.uint32()));
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.rawReturnValue = reader.bytes();
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.jsonReturnValue = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.exception = Exception.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.errorCode = longToNumber(reader.uint64());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.actionOrdinal = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.creatorActionOrdinal = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.closestUnnotifiedAncestorActionOrdinal = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.executionIndex = reader.uint32();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.filteringMatched = reader.bool();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.filteringMatchedSystemActionFilter = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionTrace {
    return {
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
      receipt: isSet(object.receipt) ? ActionReceipt.fromJSON(object.receipt) : undefined,
      action: isSet(object.action) ? Action.fromJSON(object.action) : undefined,
      contextFree: isSet(object.contextFree) ? globalThis.Boolean(object.contextFree) : false,
      elapsed: isSet(object.elapsed) ? globalThis.Number(object.elapsed) : 0,
      console: isSet(object.console) ? globalThis.String(object.console) : "",
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
      producerBlockId: isSet(object.producerBlockId) ? globalThis.String(object.producerBlockId) : "",
      blockTime: isSet(object.blockTime) ? fromJsonTimestamp(object.blockTime) : undefined,
      accountRamDeltas: globalThis.Array.isArray(object?.accountRamDeltas)
        ? object.accountRamDeltas.map((e: any) => AccountRAMDelta.fromJSON(e))
        : [],
      rawReturnValue: isSet(object.rawReturnValue) ? bytesFromBase64(object.rawReturnValue) : new Uint8Array(0),
      jsonReturnValue: isSet(object.jsonReturnValue) ? globalThis.String(object.jsonReturnValue) : "",
      exception: isSet(object.exception) ? Exception.fromJSON(object.exception) : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.Number(object.errorCode) : 0,
      actionOrdinal: isSet(object.actionOrdinal) ? globalThis.Number(object.actionOrdinal) : 0,
      creatorActionOrdinal: isSet(object.creatorActionOrdinal) ? globalThis.Number(object.creatorActionOrdinal) : 0,
      closestUnnotifiedAncestorActionOrdinal: isSet(object.closestUnnotifiedAncestorActionOrdinal)
        ? globalThis.Number(object.closestUnnotifiedAncestorActionOrdinal)
        : 0,
      executionIndex: isSet(object.executionIndex) ? globalThis.Number(object.executionIndex) : 0,
      filteringMatched: isSet(object.filteringMatched) ? globalThis.Boolean(object.filteringMatched) : false,
      filteringMatchedSystemActionFilter: isSet(object.filteringMatchedSystemActionFilter)
        ? globalThis.Boolean(object.filteringMatchedSystemActionFilter)
        : false,
    };
  },

  toJSON(message: ActionTrace): unknown {
    const obj: any = {};
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    if (message.receipt !== undefined) {
      obj.receipt = ActionReceipt.toJSON(message.receipt);
    }
    if (message.action !== undefined) {
      obj.action = Action.toJSON(message.action);
    }
    if (message.contextFree !== false) {
      obj.contextFree = message.contextFree;
    }
    if (message.elapsed !== 0) {
      obj.elapsed = Math.round(message.elapsed);
    }
    if (message.console !== "") {
      obj.console = message.console;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    if (message.producerBlockId !== "") {
      obj.producerBlockId = message.producerBlockId;
    }
    if (message.blockTime !== undefined) {
      obj.blockTime = message.blockTime.toISOString();
    }
    if (message.accountRamDeltas?.length) {
      obj.accountRamDeltas = message.accountRamDeltas.map((e) => AccountRAMDelta.toJSON(e));
    }
    if (message.rawReturnValue.length !== 0) {
      obj.rawReturnValue = base64FromBytes(message.rawReturnValue);
    }
    if (message.jsonReturnValue !== "") {
      obj.jsonReturnValue = message.jsonReturnValue;
    }
    if (message.exception !== undefined) {
      obj.exception = Exception.toJSON(message.exception);
    }
    if (message.errorCode !== 0) {
      obj.errorCode = Math.round(message.errorCode);
    }
    if (message.actionOrdinal !== 0) {
      obj.actionOrdinal = Math.round(message.actionOrdinal);
    }
    if (message.creatorActionOrdinal !== 0) {
      obj.creatorActionOrdinal = Math.round(message.creatorActionOrdinal);
    }
    if (message.closestUnnotifiedAncestorActionOrdinal !== 0) {
      obj.closestUnnotifiedAncestorActionOrdinal = Math.round(message.closestUnnotifiedAncestorActionOrdinal);
    }
    if (message.executionIndex !== 0) {
      obj.executionIndex = Math.round(message.executionIndex);
    }
    if (message.filteringMatched !== false) {
      obj.filteringMatched = message.filteringMatched;
    }
    if (message.filteringMatchedSystemActionFilter !== false) {
      obj.filteringMatchedSystemActionFilter = message.filteringMatchedSystemActionFilter;
    }
    return obj;
  },

  create(base?: DeepPartial<ActionTrace>): ActionTrace {
    return ActionTrace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionTrace>): ActionTrace {
    const message = createBaseActionTrace();
    message.receiver = object.receiver ?? "";
    message.receipt = (object.receipt !== undefined && object.receipt !== null)
      ? ActionReceipt.fromPartial(object.receipt)
      : undefined;
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    message.contextFree = object.contextFree ?? false;
    message.elapsed = object.elapsed ?? 0;
    message.console = object.console ?? "";
    message.transactionId = object.transactionId ?? "";
    message.blockNum = object.blockNum ?? 0;
    message.producerBlockId = object.producerBlockId ?? "";
    message.blockTime = object.blockTime ?? undefined;
    message.accountRamDeltas = object.accountRamDeltas?.map((e) => AccountRAMDelta.fromPartial(e)) || [];
    message.rawReturnValue = object.rawReturnValue ?? new Uint8Array(0);
    message.jsonReturnValue = object.jsonReturnValue ?? "";
    message.exception = (object.exception !== undefined && object.exception !== null)
      ? Exception.fromPartial(object.exception)
      : undefined;
    message.errorCode = object.errorCode ?? 0;
    message.actionOrdinal = object.actionOrdinal ?? 0;
    message.creatorActionOrdinal = object.creatorActionOrdinal ?? 0;
    message.closestUnnotifiedAncestorActionOrdinal = object.closestUnnotifiedAncestorActionOrdinal ?? 0;
    message.executionIndex = object.executionIndex ?? 0;
    message.filteringMatched = object.filteringMatched ?? false;
    message.filteringMatchedSystemActionFilter = object.filteringMatchedSystemActionFilter ?? false;
    return message;
  },
};

function createBaseActionReceipt(): ActionReceipt {
  return {
    receiver: "",
    digest: "",
    globalSequence: 0,
    authSequence: [],
    recvSequence: 0,
    codeSequence: 0,
    abiSequence: 0,
  };
}

export const ActionReceipt: MessageFns<ActionReceipt> = {
  encode(message: ActionReceipt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receiver !== "") {
      writer.uint32(10).string(message.receiver);
    }
    if (message.digest !== "") {
      writer.uint32(18).string(message.digest);
    }
    if (message.globalSequence !== 0) {
      writer.uint32(24).uint64(message.globalSequence);
    }
    for (const v of message.authSequence) {
      AuthSequence.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.recvSequence !== 0) {
      writer.uint32(40).uint64(message.recvSequence);
    }
    if (message.codeSequence !== 0) {
      writer.uint32(48).uint64(message.codeSequence);
    }
    if (message.abiSequence !== 0) {
      writer.uint32(56).uint64(message.abiSequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionReceipt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.receiver = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.digest = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.globalSequence = longToNumber(reader.uint64());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authSequence.push(AuthSequence.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.recvSequence = longToNumber(reader.uint64());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.codeSequence = longToNumber(reader.uint64());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.abiSequence = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionReceipt {
    return {
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
      digest: isSet(object.digest) ? globalThis.String(object.digest) : "",
      globalSequence: isSet(object.globalSequence) ? globalThis.Number(object.globalSequence) : 0,
      authSequence: globalThis.Array.isArray(object?.authSequence)
        ? object.authSequence.map((e: any) => AuthSequence.fromJSON(e))
        : [],
      recvSequence: isSet(object.recvSequence) ? globalThis.Number(object.recvSequence) : 0,
      codeSequence: isSet(object.codeSequence) ? globalThis.Number(object.codeSequence) : 0,
      abiSequence: isSet(object.abiSequence) ? globalThis.Number(object.abiSequence) : 0,
    };
  },

  toJSON(message: ActionReceipt): unknown {
    const obj: any = {};
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    if (message.digest !== "") {
      obj.digest = message.digest;
    }
    if (message.globalSequence !== 0) {
      obj.globalSequence = Math.round(message.globalSequence);
    }
    if (message.authSequence?.length) {
      obj.authSequence = message.authSequence.map((e) => AuthSequence.toJSON(e));
    }
    if (message.recvSequence !== 0) {
      obj.recvSequence = Math.round(message.recvSequence);
    }
    if (message.codeSequence !== 0) {
      obj.codeSequence = Math.round(message.codeSequence);
    }
    if (message.abiSequence !== 0) {
      obj.abiSequence = Math.round(message.abiSequence);
    }
    return obj;
  },

  create(base?: DeepPartial<ActionReceipt>): ActionReceipt {
    return ActionReceipt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionReceipt>): ActionReceipt {
    const message = createBaseActionReceipt();
    message.receiver = object.receiver ?? "";
    message.digest = object.digest ?? "";
    message.globalSequence = object.globalSequence ?? 0;
    message.authSequence = object.authSequence?.map((e) => AuthSequence.fromPartial(e)) || [];
    message.recvSequence = object.recvSequence ?? 0;
    message.codeSequence = object.codeSequence ?? 0;
    message.abiSequence = object.abiSequence ?? 0;
    return message;
  },
};

function createBaseAuthSequence(): AuthSequence {
  return { accountName: "", sequence: 0 };
}

export const AuthSequence: MessageFns<AuthSequence> = {
  encode(message: AuthSequence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountName !== "") {
      writer.uint32(10).string(message.accountName);
    }
    if (message.sequence !== 0) {
      writer.uint32(16).uint64(message.sequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthSequence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthSequence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequence = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthSequence {
    return {
      accountName: isSet(object.accountName) ? globalThis.String(object.accountName) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
    };
  },

  toJSON(message: AuthSequence): unknown {
    const obj: any = {};
    if (message.accountName !== "") {
      obj.accountName = message.accountName;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    return obj;
  },

  create(base?: DeepPartial<AuthSequence>): AuthSequence {
    return AuthSequence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthSequence>): AuthSequence {
    const message = createBaseAuthSequence();
    message.accountName = object.accountName ?? "";
    message.sequence = object.sequence ?? 0;
    return message;
  },
};

function createBaseAccountRAMDelta(): AccountRAMDelta {
  return { account: "", delta: 0 };
}

export const AccountRAMDelta: MessageFns<AccountRAMDelta> = {
  encode(message: AccountRAMDelta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.delta !== 0) {
      writer.uint32(16).int64(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountRAMDelta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountRAMDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.delta = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountRAMDelta {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      delta: isSet(object.delta) ? globalThis.Number(object.delta) : 0,
    };
  },

  toJSON(message: AccountRAMDelta): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.delta !== 0) {
      obj.delta = Math.round(message.delta);
    }
    return obj;
  },

  create(base?: DeepPartial<AccountRAMDelta>): AccountRAMDelta {
    return AccountRAMDelta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountRAMDelta>): AccountRAMDelta {
    const message = createBaseAccountRAMDelta();
    message.account = object.account ?? "";
    message.delta = object.delta ?? 0;
    return message;
  },
};

function createBaseAccountDelta(): AccountDelta {
  return { account: "", delta: 0 };
}

export const AccountDelta: MessageFns<AccountDelta> = {
  encode(message: AccountDelta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.delta !== 0) {
      writer.uint32(16).int64(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountDelta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.delta = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountDelta {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      delta: isSet(object.delta) ? globalThis.Number(object.delta) : 0,
    };
  },

  toJSON(message: AccountDelta): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.delta !== 0) {
      obj.delta = Math.round(message.delta);
    }
    return obj;
  },

  create(base?: DeepPartial<AccountDelta>): AccountDelta {
    return AccountDelta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountDelta>): AccountDelta {
    const message = createBaseAccountDelta();
    message.account = object.account ?? "";
    message.delta = object.delta ?? 0;
    return message;
  },
};

function createBaseExtension(): Extension {
  return { type: 0, data: new Uint8Array(0) };
}

export const Extension: MessageFns<Extension> = {
  encode(message: Extension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).uint32(message.type);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Extension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Extension {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: Extension): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<Extension>): Extension {
    return Extension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Extension>): Extension {
    const message = createBaseExtension();
    message.type = object.type ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTrxOp(): TrxOp {
  return { operation: 0, name: "", transactionId: "", transaction: undefined };
}

export const TrxOp: MessageFns<TrxOp> = {
  encode(message: TrxOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.transactionId !== "") {
      writer.uint32(26).string(message.transactionId);
    }
    if (message.transaction !== undefined) {
      SignedTransaction.encode(message.transaction, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrxOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrxOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transaction = SignedTransaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrxOp {
    return {
      operation: isSet(object.operation) ? trxOp_OperationFromJSON(object.operation) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      transaction: isSet(object.transaction) ? SignedTransaction.fromJSON(object.transaction) : undefined,
    };
  },

  toJSON(message: TrxOp): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = trxOp_OperationToJSON(message.operation);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.transaction !== undefined) {
      obj.transaction = SignedTransaction.toJSON(message.transaction);
    }
    return obj;
  },

  create(base?: DeepPartial<TrxOp>): TrxOp {
    return TrxOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrxOp>): TrxOp {
    const message = createBaseTrxOp();
    message.operation = object.operation ?? 0;
    message.name = object.name ?? "";
    message.transactionId = object.transactionId ?? "";
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? SignedTransaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseDBOp(): DBOp {
  return {
    operation: 0,
    actionIndex: 0,
    code: "",
    scope: "",
    tableName: "",
    primaryKey: "",
    oldPayer: "",
    newPayer: "",
    oldData: new Uint8Array(0),
    newData: new Uint8Array(0),
    oldDataJson: "",
    newDataJson: "",
  };
}

export const DBOp: MessageFns<DBOp> = {
  encode(message: DBOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.actionIndex !== 0) {
      writer.uint32(16).uint32(message.actionIndex);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.scope !== "") {
      writer.uint32(34).string(message.scope);
    }
    if (message.tableName !== "") {
      writer.uint32(42).string(message.tableName);
    }
    if (message.primaryKey !== "") {
      writer.uint32(50).string(message.primaryKey);
    }
    if (message.oldPayer !== "") {
      writer.uint32(58).string(message.oldPayer);
    }
    if (message.newPayer !== "") {
      writer.uint32(66).string(message.newPayer);
    }
    if (message.oldData.length !== 0) {
      writer.uint32(74).bytes(message.oldData);
    }
    if (message.newData.length !== 0) {
      writer.uint32(82).bytes(message.newData);
    }
    if (message.oldDataJson !== "") {
      writer.uint32(90).string(message.oldDataJson);
    }
    if (message.newDataJson !== "") {
      writer.uint32(98).string(message.newDataJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DBOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDBOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actionIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.scope = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.primaryKey = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.oldPayer = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.newPayer = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.oldData = reader.bytes();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.newData = reader.bytes();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.oldDataJson = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.newDataJson = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DBOp {
    return {
      operation: isSet(object.operation) ? dBOp_OperationFromJSON(object.operation) : 0,
      actionIndex: isSet(object.actionIndex) ? globalThis.Number(object.actionIndex) : 0,
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      primaryKey: isSet(object.primaryKey) ? globalThis.String(object.primaryKey) : "",
      oldPayer: isSet(object.oldPayer) ? globalThis.String(object.oldPayer) : "",
      newPayer: isSet(object.newPayer) ? globalThis.String(object.newPayer) : "",
      oldData: isSet(object.oldData) ? bytesFromBase64(object.oldData) : new Uint8Array(0),
      newData: isSet(object.newData) ? bytesFromBase64(object.newData) : new Uint8Array(0),
      oldDataJson: isSet(object.oldDataJson) ? globalThis.String(object.oldDataJson) : "",
      newDataJson: isSet(object.newDataJson) ? globalThis.String(object.newDataJson) : "",
    };
  },

  toJSON(message: DBOp): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = dBOp_OperationToJSON(message.operation);
    }
    if (message.actionIndex !== 0) {
      obj.actionIndex = Math.round(message.actionIndex);
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.primaryKey !== "") {
      obj.primaryKey = message.primaryKey;
    }
    if (message.oldPayer !== "") {
      obj.oldPayer = message.oldPayer;
    }
    if (message.newPayer !== "") {
      obj.newPayer = message.newPayer;
    }
    if (message.oldData.length !== 0) {
      obj.oldData = base64FromBytes(message.oldData);
    }
    if (message.newData.length !== 0) {
      obj.newData = base64FromBytes(message.newData);
    }
    if (message.oldDataJson !== "") {
      obj.oldDataJson = message.oldDataJson;
    }
    if (message.newDataJson !== "") {
      obj.newDataJson = message.newDataJson;
    }
    return obj;
  },

  create(base?: DeepPartial<DBOp>): DBOp {
    return DBOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DBOp>): DBOp {
    const message = createBaseDBOp();
    message.operation = object.operation ?? 0;
    message.actionIndex = object.actionIndex ?? 0;
    message.code = object.code ?? "";
    message.scope = object.scope ?? "";
    message.tableName = object.tableName ?? "";
    message.primaryKey = object.primaryKey ?? "";
    message.oldPayer = object.oldPayer ?? "";
    message.newPayer = object.newPayer ?? "";
    message.oldData = object.oldData ?? new Uint8Array(0);
    message.newData = object.newData ?? new Uint8Array(0);
    message.oldDataJson = object.oldDataJson ?? "";
    message.newDataJson = object.newDataJson ?? "";
    return message;
  },
};

function createBaseRAMOp(): RAMOp {
  return { operation: 0, actionIndex: 0, payer: "", delta: 0, usage: 0, namespace: 0, action: 0, uniqueKey: "" };
}

export const RAMOp: MessageFns<RAMOp> = {
  encode(message: RAMOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.actionIndex !== 0) {
      writer.uint32(16).uint32(message.actionIndex);
    }
    if (message.payer !== "") {
      writer.uint32(26).string(message.payer);
    }
    if (message.delta !== 0) {
      writer.uint32(32).int64(message.delta);
    }
    if (message.usage !== 0) {
      writer.uint32(40).uint64(message.usage);
    }
    if (message.namespace !== 0) {
      writer.uint32(48).int32(message.namespace);
    }
    if (message.action !== 0) {
      writer.uint32(56).int32(message.action);
    }
    if (message.uniqueKey !== "") {
      writer.uint32(66).string(message.uniqueKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RAMOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRAMOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actionIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payer = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.delta = longToNumber(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.usage = longToNumber(reader.uint64());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.namespace = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.uniqueKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RAMOp {
    return {
      operation: isSet(object.operation) ? rAMOp_OperationFromJSON(object.operation) : 0,
      actionIndex: isSet(object.actionIndex) ? globalThis.Number(object.actionIndex) : 0,
      payer: isSet(object.payer) ? globalThis.String(object.payer) : "",
      delta: isSet(object.delta) ? globalThis.Number(object.delta) : 0,
      usage: isSet(object.usage) ? globalThis.Number(object.usage) : 0,
      namespace: isSet(object.namespace) ? rAMOp_NamespaceFromJSON(object.namespace) : 0,
      action: isSet(object.action) ? rAMOp_ActionFromJSON(object.action) : 0,
      uniqueKey: isSet(object.uniqueKey) ? globalThis.String(object.uniqueKey) : "",
    };
  },

  toJSON(message: RAMOp): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = rAMOp_OperationToJSON(message.operation);
    }
    if (message.actionIndex !== 0) {
      obj.actionIndex = Math.round(message.actionIndex);
    }
    if (message.payer !== "") {
      obj.payer = message.payer;
    }
    if (message.delta !== 0) {
      obj.delta = Math.round(message.delta);
    }
    if (message.usage !== 0) {
      obj.usage = Math.round(message.usage);
    }
    if (message.namespace !== 0) {
      obj.namespace = rAMOp_NamespaceToJSON(message.namespace);
    }
    if (message.action !== 0) {
      obj.action = rAMOp_ActionToJSON(message.action);
    }
    if (message.uniqueKey !== "") {
      obj.uniqueKey = message.uniqueKey;
    }
    return obj;
  },

  create(base?: DeepPartial<RAMOp>): RAMOp {
    return RAMOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RAMOp>): RAMOp {
    const message = createBaseRAMOp();
    message.operation = object.operation ?? 0;
    message.actionIndex = object.actionIndex ?? 0;
    message.payer = object.payer ?? "";
    message.delta = object.delta ?? 0;
    message.usage = object.usage ?? 0;
    message.namespace = object.namespace ?? 0;
    message.action = object.action ?? 0;
    message.uniqueKey = object.uniqueKey ?? "";
    return message;
  },
};

function createBaseRAMCorrectionOp(): RAMCorrectionOp {
  return { correctionId: "", uniqueKey: "", payer: "", delta: 0 };
}

export const RAMCorrectionOp: MessageFns<RAMCorrectionOp> = {
  encode(message: RAMCorrectionOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.correctionId !== "") {
      writer.uint32(10).string(message.correctionId);
    }
    if (message.uniqueKey !== "") {
      writer.uint32(18).string(message.uniqueKey);
    }
    if (message.payer !== "") {
      writer.uint32(26).string(message.payer);
    }
    if (message.delta !== 0) {
      writer.uint32(32).int64(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RAMCorrectionOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRAMCorrectionOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.correctionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uniqueKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payer = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.delta = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RAMCorrectionOp {
    return {
      correctionId: isSet(object.correctionId) ? globalThis.String(object.correctionId) : "",
      uniqueKey: isSet(object.uniqueKey) ? globalThis.String(object.uniqueKey) : "",
      payer: isSet(object.payer) ? globalThis.String(object.payer) : "",
      delta: isSet(object.delta) ? globalThis.Number(object.delta) : 0,
    };
  },

  toJSON(message: RAMCorrectionOp): unknown {
    const obj: any = {};
    if (message.correctionId !== "") {
      obj.correctionId = message.correctionId;
    }
    if (message.uniqueKey !== "") {
      obj.uniqueKey = message.uniqueKey;
    }
    if (message.payer !== "") {
      obj.payer = message.payer;
    }
    if (message.delta !== 0) {
      obj.delta = Math.round(message.delta);
    }
    return obj;
  },

  create(base?: DeepPartial<RAMCorrectionOp>): RAMCorrectionOp {
    return RAMCorrectionOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RAMCorrectionOp>): RAMCorrectionOp {
    const message = createBaseRAMCorrectionOp();
    message.correctionId = object.correctionId ?? "";
    message.uniqueKey = object.uniqueKey ?? "";
    message.payer = object.payer ?? "";
    message.delta = object.delta ?? 0;
    return message;
  },
};

function createBaseTableOp(): TableOp {
  return { operation: 0, actionIndex: 0, payer: "", code: "", scope: "", tableName: "" };
}

export const TableOp: MessageFns<TableOp> = {
  encode(message: TableOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.actionIndex !== 0) {
      writer.uint32(16).uint32(message.actionIndex);
    }
    if (message.payer !== "") {
      writer.uint32(26).string(message.payer);
    }
    if (message.code !== "") {
      writer.uint32(34).string(message.code);
    }
    if (message.scope !== "") {
      writer.uint32(42).string(message.scope);
    }
    if (message.tableName !== "") {
      writer.uint32(50).string(message.tableName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actionIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payer = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.code = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.scope = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tableName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableOp {
    return {
      operation: isSet(object.operation) ? tableOp_OperationFromJSON(object.operation) : 0,
      actionIndex: isSet(object.actionIndex) ? globalThis.Number(object.actionIndex) : 0,
      payer: isSet(object.payer) ? globalThis.String(object.payer) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
    };
  },

  toJSON(message: TableOp): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = tableOp_OperationToJSON(message.operation);
    }
    if (message.actionIndex !== 0) {
      obj.actionIndex = Math.round(message.actionIndex);
    }
    if (message.payer !== "") {
      obj.payer = message.payer;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    return obj;
  },

  create(base?: DeepPartial<TableOp>): TableOp {
    return TableOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableOp>): TableOp {
    const message = createBaseTableOp();
    message.operation = object.operation ?? 0;
    message.actionIndex = object.actionIndex ?? 0;
    message.payer = object.payer ?? "";
    message.code = object.code ?? "";
    message.scope = object.scope ?? "";
    message.tableName = object.tableName ?? "";
    return message;
  },
};

function createBaseDTrxOp(): DTrxOp {
  return {
    operation: 0,
    actionIndex: 0,
    sender: "",
    senderId: "",
    payer: "",
    publishedAt: "",
    delayUntil: "",
    expirationAt: "",
    transactionId: "",
    transaction: undefined,
  };
}

export const DTrxOp: MessageFns<DTrxOp> = {
  encode(message: DTrxOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.actionIndex !== 0) {
      writer.uint32(16).uint32(message.actionIndex);
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    if (message.senderId !== "") {
      writer.uint32(34).string(message.senderId);
    }
    if (message.payer !== "") {
      writer.uint32(42).string(message.payer);
    }
    if (message.publishedAt !== "") {
      writer.uint32(50).string(message.publishedAt);
    }
    if (message.delayUntil !== "") {
      writer.uint32(58).string(message.delayUntil);
    }
    if (message.expirationAt !== "") {
      writer.uint32(66).string(message.expirationAt);
    }
    if (message.transactionId !== "") {
      writer.uint32(74).string(message.transactionId);
    }
    if (message.transaction !== undefined) {
      SignedTransaction.encode(message.transaction, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DTrxOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDTrxOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actionIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sender = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.senderId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payer = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.publishedAt = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.delayUntil = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.expirationAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.transaction = SignedTransaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DTrxOp {
    return {
      operation: isSet(object.operation) ? dTrxOp_OperationFromJSON(object.operation) : 0,
      actionIndex: isSet(object.actionIndex) ? globalThis.Number(object.actionIndex) : 0,
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      senderId: isSet(object.senderId) ? globalThis.String(object.senderId) : "",
      payer: isSet(object.payer) ? globalThis.String(object.payer) : "",
      publishedAt: isSet(object.publishedAt) ? globalThis.String(object.publishedAt) : "",
      delayUntil: isSet(object.delayUntil) ? globalThis.String(object.delayUntil) : "",
      expirationAt: isSet(object.expirationAt) ? globalThis.String(object.expirationAt) : "",
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      transaction: isSet(object.transaction) ? SignedTransaction.fromJSON(object.transaction) : undefined,
    };
  },

  toJSON(message: DTrxOp): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = dTrxOp_OperationToJSON(message.operation);
    }
    if (message.actionIndex !== 0) {
      obj.actionIndex = Math.round(message.actionIndex);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.senderId !== "") {
      obj.senderId = message.senderId;
    }
    if (message.payer !== "") {
      obj.payer = message.payer;
    }
    if (message.publishedAt !== "") {
      obj.publishedAt = message.publishedAt;
    }
    if (message.delayUntil !== "") {
      obj.delayUntil = message.delayUntil;
    }
    if (message.expirationAt !== "") {
      obj.expirationAt = message.expirationAt;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.transaction !== undefined) {
      obj.transaction = SignedTransaction.toJSON(message.transaction);
    }
    return obj;
  },

  create(base?: DeepPartial<DTrxOp>): DTrxOp {
    return DTrxOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DTrxOp>): DTrxOp {
    const message = createBaseDTrxOp();
    message.operation = object.operation ?? 0;
    message.actionIndex = object.actionIndex ?? 0;
    message.sender = object.sender ?? "";
    message.senderId = object.senderId ?? "";
    message.payer = object.payer ?? "";
    message.publishedAt = object.publishedAt ?? "";
    message.delayUntil = object.delayUntil ?? "";
    message.expirationAt = object.expirationAt ?? "";
    message.transactionId = object.transactionId ?? "";
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? SignedTransaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseExtDTrxOp(): ExtDTrxOp {
  return { sourceTransactionId: "", blockNum: 0, blockId: "", blockTime: undefined, dtrxOp: undefined };
}

export const ExtDTrxOp: MessageFns<ExtDTrxOp> = {
  encode(message: ExtDTrxOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceTransactionId !== "") {
      writer.uint32(10).string(message.sourceTransactionId);
    }
    if (message.blockNum !== 0) {
      writer.uint32(16).uint64(message.blockNum);
    }
    if (message.blockId !== "") {
      writer.uint32(26).string(message.blockId);
    }
    if (message.blockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.blockTime), writer.uint32(34).fork()).join();
    }
    if (message.dtrxOp !== undefined) {
      DTrxOp.encode(message.dtrxOp, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtDTrxOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtDTrxOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceTransactionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockNum = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dtrxOp = DTrxOp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtDTrxOp {
    return {
      sourceTransactionId: isSet(object.sourceTransactionId) ? globalThis.String(object.sourceTransactionId) : "",
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
      blockId: isSet(object.blockId) ? globalThis.String(object.blockId) : "",
      blockTime: isSet(object.blockTime) ? fromJsonTimestamp(object.blockTime) : undefined,
      dtrxOp: isSet(object.dtrxOp) ? DTrxOp.fromJSON(object.dtrxOp) : undefined,
    };
  },

  toJSON(message: ExtDTrxOp): unknown {
    const obj: any = {};
    if (message.sourceTransactionId !== "") {
      obj.sourceTransactionId = message.sourceTransactionId;
    }
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    if (message.blockId !== "") {
      obj.blockId = message.blockId;
    }
    if (message.blockTime !== undefined) {
      obj.blockTime = message.blockTime.toISOString();
    }
    if (message.dtrxOp !== undefined) {
      obj.dtrxOp = DTrxOp.toJSON(message.dtrxOp);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtDTrxOp>): ExtDTrxOp {
    return ExtDTrxOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtDTrxOp>): ExtDTrxOp {
    const message = createBaseExtDTrxOp();
    message.sourceTransactionId = object.sourceTransactionId ?? "";
    message.blockNum = object.blockNum ?? 0;
    message.blockId = object.blockId ?? "";
    message.blockTime = object.blockTime ?? undefined;
    message.dtrxOp = (object.dtrxOp !== undefined && object.dtrxOp !== null)
      ? DTrxOp.fromPartial(object.dtrxOp)
      : undefined;
    return message;
  },
};

function createBaseFeatureOp(): FeatureOp {
  return { kind: "", actionIndex: 0, featureDigest: "", feature: undefined };
}

export const FeatureOp: MessageFns<FeatureOp> = {
  encode(message: FeatureOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.actionIndex !== 0) {
      writer.uint32(16).uint32(message.actionIndex);
    }
    if (message.featureDigest !== "") {
      writer.uint32(26).string(message.featureDigest);
    }
    if (message.feature !== undefined) {
      Feature.encode(message.feature, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actionIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.featureDigest = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feature = Feature.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureOp {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      actionIndex: isSet(object.actionIndex) ? globalThis.Number(object.actionIndex) : 0,
      featureDigest: isSet(object.featureDigest) ? globalThis.String(object.featureDigest) : "",
      feature: isSet(object.feature) ? Feature.fromJSON(object.feature) : undefined,
    };
  },

  toJSON(message: FeatureOp): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.actionIndex !== 0) {
      obj.actionIndex = Math.round(message.actionIndex);
    }
    if (message.featureDigest !== "") {
      obj.featureDigest = message.featureDigest;
    }
    if (message.feature !== undefined) {
      obj.feature = Feature.toJSON(message.feature);
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureOp>): FeatureOp {
    return FeatureOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureOp>): FeatureOp {
    const message = createBaseFeatureOp();
    message.kind = object.kind ?? "";
    message.actionIndex = object.actionIndex ?? 0;
    message.featureDigest = object.featureDigest ?? "";
    message.feature = (object.feature !== undefined && object.feature !== null)
      ? Feature.fromPartial(object.feature)
      : undefined;
    return message;
  },
};

function createBaseCreationFlatNode(): CreationFlatNode {
  return { creatorActionIndex: 0, executionActionIndex: 0 };
}

export const CreationFlatNode: MessageFns<CreationFlatNode> = {
  encode(message: CreationFlatNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creatorActionIndex !== 0) {
      writer.uint32(8).int32(message.creatorActionIndex);
    }
    if (message.executionActionIndex !== 0) {
      writer.uint32(16).uint32(message.executionActionIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreationFlatNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreationFlatNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.creatorActionIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.executionActionIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreationFlatNode {
    return {
      creatorActionIndex: isSet(object.creatorActionIndex) ? globalThis.Number(object.creatorActionIndex) : 0,
      executionActionIndex: isSet(object.executionActionIndex) ? globalThis.Number(object.executionActionIndex) : 0,
    };
  },

  toJSON(message: CreationFlatNode): unknown {
    const obj: any = {};
    if (message.creatorActionIndex !== 0) {
      obj.creatorActionIndex = Math.round(message.creatorActionIndex);
    }
    if (message.executionActionIndex !== 0) {
      obj.executionActionIndex = Math.round(message.executionActionIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CreationFlatNode>): CreationFlatNode {
    return CreationFlatNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreationFlatNode>): CreationFlatNode {
    const message = createBaseCreationFlatNode();
    message.creatorActionIndex = object.creatorActionIndex ?? 0;
    message.executionActionIndex = object.executionActionIndex ?? 0;
    return message;
  },
};

function createBasePermOp(): PermOp {
  return { operation: 0, actionIndex: 0, oldPerm: undefined, newPerm: undefined };
}

export const PermOp: MessageFns<PermOp> = {
  encode(message: PermOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.actionIndex !== 0) {
      writer.uint32(16).uint32(message.actionIndex);
    }
    if (message.oldPerm !== undefined) {
      PermissionObject.encode(message.oldPerm, writer.uint32(66).fork()).join();
    }
    if (message.newPerm !== undefined) {
      PermissionObject.encode(message.newPerm, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actionIndex = reader.uint32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.oldPerm = PermissionObject.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.newPerm = PermissionObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermOp {
    return {
      operation: isSet(object.operation) ? permOp_OperationFromJSON(object.operation) : 0,
      actionIndex: isSet(object.actionIndex) ? globalThis.Number(object.actionIndex) : 0,
      oldPerm: isSet(object.oldPerm) ? PermissionObject.fromJSON(object.oldPerm) : undefined,
      newPerm: isSet(object.newPerm) ? PermissionObject.fromJSON(object.newPerm) : undefined,
    };
  },

  toJSON(message: PermOp): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = permOp_OperationToJSON(message.operation);
    }
    if (message.actionIndex !== 0) {
      obj.actionIndex = Math.round(message.actionIndex);
    }
    if (message.oldPerm !== undefined) {
      obj.oldPerm = PermissionObject.toJSON(message.oldPerm);
    }
    if (message.newPerm !== undefined) {
      obj.newPerm = PermissionObject.toJSON(message.newPerm);
    }
    return obj;
  },

  create(base?: DeepPartial<PermOp>): PermOp {
    return PermOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PermOp>): PermOp {
    const message = createBasePermOp();
    message.operation = object.operation ?? 0;
    message.actionIndex = object.actionIndex ?? 0;
    message.oldPerm = (object.oldPerm !== undefined && object.oldPerm !== null)
      ? PermissionObject.fromPartial(object.oldPerm)
      : undefined;
    message.newPerm = (object.newPerm !== undefined && object.newPerm !== null)
      ? PermissionObject.fromPartial(object.newPerm)
      : undefined;
    return message;
  },
};

function createBasePermissionObject(): PermissionObject {
  return { id: 0, parentId: 0, owner: "", name: "", lastUpdated: undefined, authority: undefined };
}

export const PermissionObject: MessageFns<PermissionObject> = {
  encode(message: PermissionObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(80).uint64(message.id);
    }
    if (message.parentId !== 0) {
      writer.uint32(88).uint64(message.parentId);
    }
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.lastUpdated !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdated), writer.uint32(26).fork()).join();
    }
    if (message.authority !== undefined) {
      Authority.encode(message.authority, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10:
          if (tag !== 80) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.parentId = longToNumber(reader.uint64());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lastUpdated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authority = Authority.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionObject {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      parentId: isSet(object.parentId) ? globalThis.Number(object.parentId) : 0,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      lastUpdated: isSet(object.lastUpdated) ? fromJsonTimestamp(object.lastUpdated) : undefined,
      authority: isSet(object.authority) ? Authority.fromJSON(object.authority) : undefined,
    };
  },

  toJSON(message: PermissionObject): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.parentId !== 0) {
      obj.parentId = Math.round(message.parentId);
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.lastUpdated !== undefined) {
      obj.lastUpdated = message.lastUpdated.toISOString();
    }
    if (message.authority !== undefined) {
      obj.authority = Authority.toJSON(message.authority);
    }
    return obj;
  },

  create(base?: DeepPartial<PermissionObject>): PermissionObject {
    return PermissionObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PermissionObject>): PermissionObject {
    const message = createBasePermissionObject();
    message.id = object.id ?? 0;
    message.parentId = object.parentId ?? 0;
    message.owner = object.owner ?? "";
    message.name = object.name ?? "";
    message.lastUpdated = object.lastUpdated ?? undefined;
    message.authority = (object.authority !== undefined && object.authority !== null)
      ? Authority.fromPartial(object.authority)
      : undefined;
    return message;
  },
};

function createBasePermission(): Permission {
  return { name: "", parent: "", requiredAuth: undefined };
}

export const Permission: MessageFns<Permission> = {
  encode(message: Permission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.requiredAuth !== undefined) {
      Authority.encode(message.requiredAuth, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Permission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requiredAuth = Authority.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Permission {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requiredAuth: isSet(object.requiredAuth) ? Authority.fromJSON(object.requiredAuth) : undefined,
    };
  },

  toJSON(message: Permission): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requiredAuth !== undefined) {
      obj.requiredAuth = Authority.toJSON(message.requiredAuth);
    }
    return obj;
  },

  create(base?: DeepPartial<Permission>): Permission {
    return Permission.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Permission>): Permission {
    const message = createBasePermission();
    message.name = object.name ?? "";
    message.parent = object.parent ?? "";
    message.requiredAuth = (object.requiredAuth !== undefined && object.requiredAuth !== null)
      ? Authority.fromPartial(object.requiredAuth)
      : undefined;
    return message;
  },
};

function createBaseAuthority(): Authority {
  return { threshold: 0, keys: [], accounts: [], waits: [] };
}

export const Authority: MessageFns<Authority> = {
  encode(message: Authority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threshold !== 0) {
      writer.uint32(8).uint32(message.threshold);
    }
    for (const v of message.keys) {
      KeyWeight.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.accounts) {
      PermissionLevelWeight.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.waits) {
      WaitWeight.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keys.push(KeyWeight.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accounts.push(PermissionLevelWeight.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.waits.push(WaitWeight.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authority {
    return {
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => KeyWeight.fromJSON(e)) : [],
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => PermissionLevelWeight.fromJSON(e))
        : [],
      waits: globalThis.Array.isArray(object?.waits) ? object.waits.map((e: any) => WaitWeight.fromJSON(e)) : [],
    };
  },

  toJSON(message: Authority): unknown {
    const obj: any = {};
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => KeyWeight.toJSON(e));
    }
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => PermissionLevelWeight.toJSON(e));
    }
    if (message.waits?.length) {
      obj.waits = message.waits.map((e) => WaitWeight.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Authority>): Authority {
    return Authority.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Authority>): Authority {
    const message = createBaseAuthority();
    message.threshold = object.threshold ?? 0;
    message.keys = object.keys?.map((e) => KeyWeight.fromPartial(e)) || [];
    message.accounts = object.accounts?.map((e) => PermissionLevelWeight.fromPartial(e)) || [];
    message.waits = object.waits?.map((e) => WaitWeight.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeyWeight(): KeyWeight {
  return { publicKey: "", weight: 0 };
}

export const KeyWeight: MessageFns<KeyWeight> = {
  encode(message: KeyWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    if (message.weight !== 0) {
      writer.uint32(16).uint32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.weight = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyWeight {
    return {
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: KeyWeight): unknown {
    const obj: any = {};
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create(base?: DeepPartial<KeyWeight>): KeyWeight {
    return KeyWeight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyWeight>): KeyWeight {
    const message = createBaseKeyWeight();
    message.publicKey = object.publicKey ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBasePermissionLevel(): PermissionLevel {
  return { actor: "", permission: "" };
}

export const PermissionLevel: MessageFns<PermissionLevel> = {
  encode(message: PermissionLevel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actor !== "") {
      writer.uint32(10).string(message.actor);
    }
    if (message.permission !== "") {
      writer.uint32(18).string(message.permission);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionLevel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permission = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionLevel {
    return {
      actor: isSet(object.actor) ? globalThis.String(object.actor) : "",
      permission: isSet(object.permission) ? globalThis.String(object.permission) : "",
    };
  },

  toJSON(message: PermissionLevel): unknown {
    const obj: any = {};
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    if (message.permission !== "") {
      obj.permission = message.permission;
    }
    return obj;
  },

  create(base?: DeepPartial<PermissionLevel>): PermissionLevel {
    return PermissionLevel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PermissionLevel>): PermissionLevel {
    const message = createBasePermissionLevel();
    message.actor = object.actor ?? "";
    message.permission = object.permission ?? "";
    return message;
  },
};

function createBasePermissionLevelWeight(): PermissionLevelWeight {
  return { permission: undefined, weight: 0 };
}

export const PermissionLevelWeight: MessageFns<PermissionLevelWeight> = {
  encode(message: PermissionLevelWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.permission !== undefined) {
      PermissionLevel.encode(message.permission, writer.uint32(10).fork()).join();
    }
    if (message.weight !== 0) {
      writer.uint32(16).uint32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionLevelWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionLevelWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permission = PermissionLevel.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.weight = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionLevelWeight {
    return {
      permission: isSet(object.permission) ? PermissionLevel.fromJSON(object.permission) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: PermissionLevelWeight): unknown {
    const obj: any = {};
    if (message.permission !== undefined) {
      obj.permission = PermissionLevel.toJSON(message.permission);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create(base?: DeepPartial<PermissionLevelWeight>): PermissionLevelWeight {
    return PermissionLevelWeight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PermissionLevelWeight>): PermissionLevelWeight {
    const message = createBasePermissionLevelWeight();
    message.permission = (object.permission !== undefined && object.permission !== null)
      ? PermissionLevel.fromPartial(object.permission)
      : undefined;
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseWaitWeight(): WaitWeight {
  return { waitSec: 0, weight: 0 };
}

export const WaitWeight: MessageFns<WaitWeight> = {
  encode(message: WaitWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.waitSec !== 0) {
      writer.uint32(8).uint32(message.waitSec);
    }
    if (message.weight !== 0) {
      writer.uint32(16).uint32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WaitWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.waitSec = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.weight = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WaitWeight {
    return {
      waitSec: isSet(object.waitSec) ? globalThis.Number(object.waitSec) : 0,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: WaitWeight): unknown {
    const obj: any = {};
    if (message.waitSec !== 0) {
      obj.waitSec = Math.round(message.waitSec);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create(base?: DeepPartial<WaitWeight>): WaitWeight {
    return WaitWeight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WaitWeight>): WaitWeight {
    const message = createBaseWaitWeight();
    message.waitSec = object.waitSec ?? 0;
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseRlimitOp(): RlimitOp {
  return { operation: 0, state: undefined, config: undefined, accountLimits: undefined, accountUsage: undefined };
}

export const RlimitOp: MessageFns<RlimitOp> = {
  encode(message: RlimitOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.state !== undefined) {
      RlimitState.encode(message.state, writer.uint32(18).fork()).join();
    }
    if (message.config !== undefined) {
      RlimitConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    if (message.accountLimits !== undefined) {
      RlimitAccountLimits.encode(message.accountLimits, writer.uint32(34).fork()).join();
    }
    if (message.accountUsage !== undefined) {
      RlimitAccountUsage.encode(message.accountUsage, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RlimitOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRlimitOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = RlimitState.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.config = RlimitConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.accountLimits = RlimitAccountLimits.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.accountUsage = RlimitAccountUsage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RlimitOp {
    return {
      operation: isSet(object.operation) ? rlimitOp_OperationFromJSON(object.operation) : 0,
      state: isSet(object.state) ? RlimitState.fromJSON(object.state) : undefined,
      config: isSet(object.config) ? RlimitConfig.fromJSON(object.config) : undefined,
      accountLimits: isSet(object.accountLimits) ? RlimitAccountLimits.fromJSON(object.accountLimits) : undefined,
      accountUsage: isSet(object.accountUsage) ? RlimitAccountUsage.fromJSON(object.accountUsage) : undefined,
    };
  },

  toJSON(message: RlimitOp): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = rlimitOp_OperationToJSON(message.operation);
    }
    if (message.state !== undefined) {
      obj.state = RlimitState.toJSON(message.state);
    }
    if (message.config !== undefined) {
      obj.config = RlimitConfig.toJSON(message.config);
    }
    if (message.accountLimits !== undefined) {
      obj.accountLimits = RlimitAccountLimits.toJSON(message.accountLimits);
    }
    if (message.accountUsage !== undefined) {
      obj.accountUsage = RlimitAccountUsage.toJSON(message.accountUsage);
    }
    return obj;
  },

  create(base?: DeepPartial<RlimitOp>): RlimitOp {
    return RlimitOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RlimitOp>): RlimitOp {
    const message = createBaseRlimitOp();
    message.operation = object.operation ?? 0;
    message.state = (object.state !== undefined && object.state !== null)
      ? RlimitState.fromPartial(object.state)
      : undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? RlimitConfig.fromPartial(object.config)
      : undefined;
    message.accountLimits = (object.accountLimits !== undefined && object.accountLimits !== null)
      ? RlimitAccountLimits.fromPartial(object.accountLimits)
      : undefined;
    message.accountUsage = (object.accountUsage !== undefined && object.accountUsage !== null)
      ? RlimitAccountUsage.fromPartial(object.accountUsage)
      : undefined;
    return message;
  },
};

function createBaseRlimitState(): RlimitState {
  return {
    averageBlockNetUsage: undefined,
    averageBlockCpuUsage: undefined,
    pendingNetUsage: 0,
    pendingCpuUsage: 0,
    totalNetWeight: 0,
    totalCpuWeight: 0,
    totalRamBytes: 0,
    virtualNetLimit: 0,
    virtualCpuLimit: 0,
  };
}

export const RlimitState: MessageFns<RlimitState> = {
  encode(message: RlimitState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.averageBlockNetUsage !== undefined) {
      UsageAccumulator.encode(message.averageBlockNetUsage, writer.uint32(10).fork()).join();
    }
    if (message.averageBlockCpuUsage !== undefined) {
      UsageAccumulator.encode(message.averageBlockCpuUsage, writer.uint32(18).fork()).join();
    }
    if (message.pendingNetUsage !== 0) {
      writer.uint32(24).uint64(message.pendingNetUsage);
    }
    if (message.pendingCpuUsage !== 0) {
      writer.uint32(32).uint64(message.pendingCpuUsage);
    }
    if (message.totalNetWeight !== 0) {
      writer.uint32(40).uint64(message.totalNetWeight);
    }
    if (message.totalCpuWeight !== 0) {
      writer.uint32(48).uint64(message.totalCpuWeight);
    }
    if (message.totalRamBytes !== 0) {
      writer.uint32(56).uint64(message.totalRamBytes);
    }
    if (message.virtualNetLimit !== 0) {
      writer.uint32(64).uint64(message.virtualNetLimit);
    }
    if (message.virtualCpuLimit !== 0) {
      writer.uint32(72).uint64(message.virtualCpuLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RlimitState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRlimitState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.averageBlockNetUsage = UsageAccumulator.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.averageBlockCpuUsage = UsageAccumulator.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pendingNetUsage = longToNumber(reader.uint64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pendingCpuUsage = longToNumber(reader.uint64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalNetWeight = longToNumber(reader.uint64());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalCpuWeight = longToNumber(reader.uint64());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.totalRamBytes = longToNumber(reader.uint64());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.virtualNetLimit = longToNumber(reader.uint64());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.virtualCpuLimit = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RlimitState {
    return {
      averageBlockNetUsage: isSet(object.averageBlockNetUsage)
        ? UsageAccumulator.fromJSON(object.averageBlockNetUsage)
        : undefined,
      averageBlockCpuUsage: isSet(object.averageBlockCpuUsage)
        ? UsageAccumulator.fromJSON(object.averageBlockCpuUsage)
        : undefined,
      pendingNetUsage: isSet(object.pendingNetUsage) ? globalThis.Number(object.pendingNetUsage) : 0,
      pendingCpuUsage: isSet(object.pendingCpuUsage) ? globalThis.Number(object.pendingCpuUsage) : 0,
      totalNetWeight: isSet(object.totalNetWeight) ? globalThis.Number(object.totalNetWeight) : 0,
      totalCpuWeight: isSet(object.totalCpuWeight) ? globalThis.Number(object.totalCpuWeight) : 0,
      totalRamBytes: isSet(object.totalRamBytes) ? globalThis.Number(object.totalRamBytes) : 0,
      virtualNetLimit: isSet(object.virtualNetLimit) ? globalThis.Number(object.virtualNetLimit) : 0,
      virtualCpuLimit: isSet(object.virtualCpuLimit) ? globalThis.Number(object.virtualCpuLimit) : 0,
    };
  },

  toJSON(message: RlimitState): unknown {
    const obj: any = {};
    if (message.averageBlockNetUsage !== undefined) {
      obj.averageBlockNetUsage = UsageAccumulator.toJSON(message.averageBlockNetUsage);
    }
    if (message.averageBlockCpuUsage !== undefined) {
      obj.averageBlockCpuUsage = UsageAccumulator.toJSON(message.averageBlockCpuUsage);
    }
    if (message.pendingNetUsage !== 0) {
      obj.pendingNetUsage = Math.round(message.pendingNetUsage);
    }
    if (message.pendingCpuUsage !== 0) {
      obj.pendingCpuUsage = Math.round(message.pendingCpuUsage);
    }
    if (message.totalNetWeight !== 0) {
      obj.totalNetWeight = Math.round(message.totalNetWeight);
    }
    if (message.totalCpuWeight !== 0) {
      obj.totalCpuWeight = Math.round(message.totalCpuWeight);
    }
    if (message.totalRamBytes !== 0) {
      obj.totalRamBytes = Math.round(message.totalRamBytes);
    }
    if (message.virtualNetLimit !== 0) {
      obj.virtualNetLimit = Math.round(message.virtualNetLimit);
    }
    if (message.virtualCpuLimit !== 0) {
      obj.virtualCpuLimit = Math.round(message.virtualCpuLimit);
    }
    return obj;
  },

  create(base?: DeepPartial<RlimitState>): RlimitState {
    return RlimitState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RlimitState>): RlimitState {
    const message = createBaseRlimitState();
    message.averageBlockNetUsage = (object.averageBlockNetUsage !== undefined && object.averageBlockNetUsage !== null)
      ? UsageAccumulator.fromPartial(object.averageBlockNetUsage)
      : undefined;
    message.averageBlockCpuUsage = (object.averageBlockCpuUsage !== undefined && object.averageBlockCpuUsage !== null)
      ? UsageAccumulator.fromPartial(object.averageBlockCpuUsage)
      : undefined;
    message.pendingNetUsage = object.pendingNetUsage ?? 0;
    message.pendingCpuUsage = object.pendingCpuUsage ?? 0;
    message.totalNetWeight = object.totalNetWeight ?? 0;
    message.totalCpuWeight = object.totalCpuWeight ?? 0;
    message.totalRamBytes = object.totalRamBytes ?? 0;
    message.virtualNetLimit = object.virtualNetLimit ?? 0;
    message.virtualCpuLimit = object.virtualCpuLimit ?? 0;
    return message;
  },
};

function createBaseRlimitConfig(): RlimitConfig {
  return {
    cpuLimitParameters: undefined,
    netLimitParameters: undefined,
    accountCpuUsageAverageWindow: 0,
    accountNetUsageAverageWindow: 0,
  };
}

export const RlimitConfig: MessageFns<RlimitConfig> = {
  encode(message: RlimitConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuLimitParameters !== undefined) {
      ElasticLimitParameters.encode(message.cpuLimitParameters, writer.uint32(10).fork()).join();
    }
    if (message.netLimitParameters !== undefined) {
      ElasticLimitParameters.encode(message.netLimitParameters, writer.uint32(18).fork()).join();
    }
    if (message.accountCpuUsageAverageWindow !== 0) {
      writer.uint32(24).uint32(message.accountCpuUsageAverageWindow);
    }
    if (message.accountNetUsageAverageWindow !== 0) {
      writer.uint32(32).uint32(message.accountNetUsageAverageWindow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RlimitConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRlimitConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpuLimitParameters = ElasticLimitParameters.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.netLimitParameters = ElasticLimitParameters.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.accountCpuUsageAverageWindow = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.accountNetUsageAverageWindow = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RlimitConfig {
    return {
      cpuLimitParameters: isSet(object.cpuLimitParameters)
        ? ElasticLimitParameters.fromJSON(object.cpuLimitParameters)
        : undefined,
      netLimitParameters: isSet(object.netLimitParameters)
        ? ElasticLimitParameters.fromJSON(object.netLimitParameters)
        : undefined,
      accountCpuUsageAverageWindow: isSet(object.accountCpuUsageAverageWindow)
        ? globalThis.Number(object.accountCpuUsageAverageWindow)
        : 0,
      accountNetUsageAverageWindow: isSet(object.accountNetUsageAverageWindow)
        ? globalThis.Number(object.accountNetUsageAverageWindow)
        : 0,
    };
  },

  toJSON(message: RlimitConfig): unknown {
    const obj: any = {};
    if (message.cpuLimitParameters !== undefined) {
      obj.cpuLimitParameters = ElasticLimitParameters.toJSON(message.cpuLimitParameters);
    }
    if (message.netLimitParameters !== undefined) {
      obj.netLimitParameters = ElasticLimitParameters.toJSON(message.netLimitParameters);
    }
    if (message.accountCpuUsageAverageWindow !== 0) {
      obj.accountCpuUsageAverageWindow = Math.round(message.accountCpuUsageAverageWindow);
    }
    if (message.accountNetUsageAverageWindow !== 0) {
      obj.accountNetUsageAverageWindow = Math.round(message.accountNetUsageAverageWindow);
    }
    return obj;
  },

  create(base?: DeepPartial<RlimitConfig>): RlimitConfig {
    return RlimitConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RlimitConfig>): RlimitConfig {
    const message = createBaseRlimitConfig();
    message.cpuLimitParameters = (object.cpuLimitParameters !== undefined && object.cpuLimitParameters !== null)
      ? ElasticLimitParameters.fromPartial(object.cpuLimitParameters)
      : undefined;
    message.netLimitParameters = (object.netLimitParameters !== undefined && object.netLimitParameters !== null)
      ? ElasticLimitParameters.fromPartial(object.netLimitParameters)
      : undefined;
    message.accountCpuUsageAverageWindow = object.accountCpuUsageAverageWindow ?? 0;
    message.accountNetUsageAverageWindow = object.accountNetUsageAverageWindow ?? 0;
    return message;
  },
};

function createBaseRlimitAccountLimits(): RlimitAccountLimits {
  return { owner: "", pending: false, netWeight: 0, cpuWeight: 0, ramBytes: 0 };
}

export const RlimitAccountLimits: MessageFns<RlimitAccountLimits> = {
  encode(message: RlimitAccountLimits, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.pending !== false) {
      writer.uint32(16).bool(message.pending);
    }
    if (message.netWeight !== 0) {
      writer.uint32(24).int64(message.netWeight);
    }
    if (message.cpuWeight !== 0) {
      writer.uint32(32).int64(message.cpuWeight);
    }
    if (message.ramBytes !== 0) {
      writer.uint32(40).int64(message.ramBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RlimitAccountLimits {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRlimitAccountLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pending = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.netWeight = longToNumber(reader.int64());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cpuWeight = longToNumber(reader.int64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ramBytes = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RlimitAccountLimits {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      pending: isSet(object.pending) ? globalThis.Boolean(object.pending) : false,
      netWeight: isSet(object.netWeight) ? globalThis.Number(object.netWeight) : 0,
      cpuWeight: isSet(object.cpuWeight) ? globalThis.Number(object.cpuWeight) : 0,
      ramBytes: isSet(object.ramBytes) ? globalThis.Number(object.ramBytes) : 0,
    };
  },

  toJSON(message: RlimitAccountLimits): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.pending !== false) {
      obj.pending = message.pending;
    }
    if (message.netWeight !== 0) {
      obj.netWeight = Math.round(message.netWeight);
    }
    if (message.cpuWeight !== 0) {
      obj.cpuWeight = Math.round(message.cpuWeight);
    }
    if (message.ramBytes !== 0) {
      obj.ramBytes = Math.round(message.ramBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<RlimitAccountLimits>): RlimitAccountLimits {
    return RlimitAccountLimits.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RlimitAccountLimits>): RlimitAccountLimits {
    const message = createBaseRlimitAccountLimits();
    message.owner = object.owner ?? "";
    message.pending = object.pending ?? false;
    message.netWeight = object.netWeight ?? 0;
    message.cpuWeight = object.cpuWeight ?? 0;
    message.ramBytes = object.ramBytes ?? 0;
    return message;
  },
};

function createBaseRlimitAccountUsage(): RlimitAccountUsage {
  return { owner: "", netUsage: undefined, cpuUsage: undefined, ramUsage: 0 };
}

export const RlimitAccountUsage: MessageFns<RlimitAccountUsage> = {
  encode(message: RlimitAccountUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.netUsage !== undefined) {
      UsageAccumulator.encode(message.netUsage, writer.uint32(18).fork()).join();
    }
    if (message.cpuUsage !== undefined) {
      UsageAccumulator.encode(message.cpuUsage, writer.uint32(26).fork()).join();
    }
    if (message.ramUsage !== 0) {
      writer.uint32(32).uint64(message.ramUsage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RlimitAccountUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRlimitAccountUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.netUsage = UsageAccumulator.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cpuUsage = UsageAccumulator.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ramUsage = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RlimitAccountUsage {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      netUsage: isSet(object.netUsage) ? UsageAccumulator.fromJSON(object.netUsage) : undefined,
      cpuUsage: isSet(object.cpuUsage) ? UsageAccumulator.fromJSON(object.cpuUsage) : undefined,
      ramUsage: isSet(object.ramUsage) ? globalThis.Number(object.ramUsage) : 0,
    };
  },

  toJSON(message: RlimitAccountUsage): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.netUsage !== undefined) {
      obj.netUsage = UsageAccumulator.toJSON(message.netUsage);
    }
    if (message.cpuUsage !== undefined) {
      obj.cpuUsage = UsageAccumulator.toJSON(message.cpuUsage);
    }
    if (message.ramUsage !== 0) {
      obj.ramUsage = Math.round(message.ramUsage);
    }
    return obj;
  },

  create(base?: DeepPartial<RlimitAccountUsage>): RlimitAccountUsage {
    return RlimitAccountUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RlimitAccountUsage>): RlimitAccountUsage {
    const message = createBaseRlimitAccountUsage();
    message.owner = object.owner ?? "";
    message.netUsage = (object.netUsage !== undefined && object.netUsage !== null)
      ? UsageAccumulator.fromPartial(object.netUsage)
      : undefined;
    message.cpuUsage = (object.cpuUsage !== undefined && object.cpuUsage !== null)
      ? UsageAccumulator.fromPartial(object.cpuUsage)
      : undefined;
    message.ramUsage = object.ramUsage ?? 0;
    return message;
  },
};

function createBaseUsageAccumulator(): UsageAccumulator {
  return { lastOrdinal: 0, valueEx: 0, consumed: 0 };
}

export const UsageAccumulator: MessageFns<UsageAccumulator> = {
  encode(message: UsageAccumulator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastOrdinal !== 0) {
      writer.uint32(8).uint32(message.lastOrdinal);
    }
    if (message.valueEx !== 0) {
      writer.uint32(16).uint64(message.valueEx);
    }
    if (message.consumed !== 0) {
      writer.uint32(24).uint64(message.consumed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsageAccumulator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsageAccumulator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lastOrdinal = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.valueEx = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.consumed = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsageAccumulator {
    return {
      lastOrdinal: isSet(object.lastOrdinal) ? globalThis.Number(object.lastOrdinal) : 0,
      valueEx: isSet(object.valueEx) ? globalThis.Number(object.valueEx) : 0,
      consumed: isSet(object.consumed) ? globalThis.Number(object.consumed) : 0,
    };
  },

  toJSON(message: UsageAccumulator): unknown {
    const obj: any = {};
    if (message.lastOrdinal !== 0) {
      obj.lastOrdinal = Math.round(message.lastOrdinal);
    }
    if (message.valueEx !== 0) {
      obj.valueEx = Math.round(message.valueEx);
    }
    if (message.consumed !== 0) {
      obj.consumed = Math.round(message.consumed);
    }
    return obj;
  },

  create(base?: DeepPartial<UsageAccumulator>): UsageAccumulator {
    return UsageAccumulator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UsageAccumulator>): UsageAccumulator {
    const message = createBaseUsageAccumulator();
    message.lastOrdinal = object.lastOrdinal ?? 0;
    message.valueEx = object.valueEx ?? 0;
    message.consumed = object.consumed ?? 0;
    return message;
  },
};

function createBaseElasticLimitParameters(): ElasticLimitParameters {
  return { target: 0, max: 0, periods: 0, maxMultiplier: 0, contractRate: undefined, expandRate: undefined };
}

export const ElasticLimitParameters: MessageFns<ElasticLimitParameters> = {
  encode(message: ElasticLimitParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== 0) {
      writer.uint32(8).uint64(message.target);
    }
    if (message.max !== 0) {
      writer.uint32(16).uint64(message.max);
    }
    if (message.periods !== 0) {
      writer.uint32(24).uint32(message.periods);
    }
    if (message.maxMultiplier !== 0) {
      writer.uint32(32).uint32(message.maxMultiplier);
    }
    if (message.contractRate !== undefined) {
      Ratio.encode(message.contractRate, writer.uint32(42).fork()).join();
    }
    if (message.expandRate !== undefined) {
      Ratio.encode(message.expandRate, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ElasticLimitParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElasticLimitParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.target = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.max = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.periods = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxMultiplier = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contractRate = Ratio.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.expandRate = Ratio.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElasticLimitParameters {
    return {
      target: isSet(object.target) ? globalThis.Number(object.target) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
      periods: isSet(object.periods) ? globalThis.Number(object.periods) : 0,
      maxMultiplier: isSet(object.maxMultiplier) ? globalThis.Number(object.maxMultiplier) : 0,
      contractRate: isSet(object.contractRate) ? Ratio.fromJSON(object.contractRate) : undefined,
      expandRate: isSet(object.expandRate) ? Ratio.fromJSON(object.expandRate) : undefined,
    };
  },

  toJSON(message: ElasticLimitParameters): unknown {
    const obj: any = {};
    if (message.target !== 0) {
      obj.target = Math.round(message.target);
    }
    if (message.max !== 0) {
      obj.max = Math.round(message.max);
    }
    if (message.periods !== 0) {
      obj.periods = Math.round(message.periods);
    }
    if (message.maxMultiplier !== 0) {
      obj.maxMultiplier = Math.round(message.maxMultiplier);
    }
    if (message.contractRate !== undefined) {
      obj.contractRate = Ratio.toJSON(message.contractRate);
    }
    if (message.expandRate !== undefined) {
      obj.expandRate = Ratio.toJSON(message.expandRate);
    }
    return obj;
  },

  create(base?: DeepPartial<ElasticLimitParameters>): ElasticLimitParameters {
    return ElasticLimitParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ElasticLimitParameters>): ElasticLimitParameters {
    const message = createBaseElasticLimitParameters();
    message.target = object.target ?? 0;
    message.max = object.max ?? 0;
    message.periods = object.periods ?? 0;
    message.maxMultiplier = object.maxMultiplier ?? 0;
    message.contractRate = (object.contractRate !== undefined && object.contractRate !== null)
      ? Ratio.fromPartial(object.contractRate)
      : undefined;
    message.expandRate = (object.expandRate !== undefined && object.expandRate !== null)
      ? Ratio.fromPartial(object.expandRate)
      : undefined;
    return message;
  },
};

function createBaseRatio(): Ratio {
  return { numerator: 0, denominator: 0 };
}

export const Ratio: MessageFns<Ratio> = {
  encode(message: Ratio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numerator !== 0) {
      writer.uint32(8).uint64(message.numerator);
    }
    if (message.denominator !== 0) {
      writer.uint32(16).uint64(message.denominator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ratio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRatio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.numerator = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.denominator = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ratio {
    return {
      numerator: isSet(object.numerator) ? globalThis.Number(object.numerator) : 0,
      denominator: isSet(object.denominator) ? globalThis.Number(object.denominator) : 0,
    };
  },

  toJSON(message: Ratio): unknown {
    const obj: any = {};
    if (message.numerator !== 0) {
      obj.numerator = Math.round(message.numerator);
    }
    if (message.denominator !== 0) {
      obj.denominator = Math.round(message.denominator);
    }
    return obj;
  },

  create(base?: DeepPartial<Ratio>): Ratio {
    return Ratio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Ratio>): Ratio {
    const message = createBaseRatio();
    message.numerator = object.numerator ?? 0;
    message.denominator = object.denominator ?? 0;
    return message;
  },
};

function createBaseException(): Exception {
  return { code: 0, name: "", message: "", stack: [] };
}

export const Exception: MessageFns<Exception> = {
  encode(message: Exception, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    for (const v of message.stack) {
      Exception_LogMessage.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Exception {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseException();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stack.push(Exception_LogMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exception {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      stack: globalThis.Array.isArray(object?.stack)
        ? object.stack.map((e: any) => Exception_LogMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Exception): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.stack?.length) {
      obj.stack = message.stack.map((e) => Exception_LogMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Exception>): Exception {
    return Exception.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Exception>): Exception {
    const message = createBaseException();
    message.code = object.code ?? 0;
    message.name = object.name ?? "";
    message.message = object.message ?? "";
    message.stack = object.stack?.map((e) => Exception_LogMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseException_LogMessage(): Exception_LogMessage {
  return { context: undefined, format: "", data: new Uint8Array(0) };
}

export const Exception_LogMessage: MessageFns<Exception_LogMessage> = {
  encode(message: Exception_LogMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      Exception_LogContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Exception_LogMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseException_LogMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = Exception_LogContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exception_LogMessage {
    return {
      context: isSet(object.context) ? Exception_LogContext.fromJSON(object.context) : undefined,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: Exception_LogMessage): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = Exception_LogContext.toJSON(message.context);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<Exception_LogMessage>): Exception_LogMessage {
    return Exception_LogMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Exception_LogMessage>): Exception_LogMessage {
    const message = createBaseException_LogMessage();
    message.context = (object.context !== undefined && object.context !== null)
      ? Exception_LogContext.fromPartial(object.context)
      : undefined;
    message.format = object.format ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseException_LogContext(): Exception_LogContext {
  return {
    level: "",
    file: "",
    line: 0,
    method: "",
    hostname: "",
    threadName: "",
    timestamp: undefined,
    context: undefined,
  };
}

export const Exception_LogContext: MessageFns<Exception_LogContext> = {
  encode(message: Exception_LogContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== "") {
      writer.uint32(10).string(message.level);
    }
    if (message.file !== "") {
      writer.uint32(18).string(message.file);
    }
    if (message.line !== 0) {
      writer.uint32(24).int32(message.line);
    }
    if (message.method !== "") {
      writer.uint32(34).string(message.method);
    }
    if (message.hostname !== "") {
      writer.uint32(42).string(message.hostname);
    }
    if (message.threadName !== "") {
      writer.uint32(50).string(message.threadName);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(58).fork()).join();
    }
    if (message.context !== undefined) {
      Exception_LogContext.encode(message.context, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Exception_LogContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseException_LogContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.level = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.file = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.line = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.method = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.threadName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.context = Exception_LogContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exception_LogContext {
    return {
      level: isSet(object.level) ? globalThis.String(object.level) : "",
      file: isSet(object.file) ? globalThis.String(object.file) : "",
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      threadName: isSet(object.threadName) ? globalThis.String(object.threadName) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      context: isSet(object.context) ? Exception_LogContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: Exception_LogContext): unknown {
    const obj: any = {};
    if (message.level !== "") {
      obj.level = message.level;
    }
    if (message.file !== "") {
      obj.file = message.file;
    }
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.threadName !== "") {
      obj.threadName = message.threadName;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.context !== undefined) {
      obj.context = Exception_LogContext.toJSON(message.context);
    }
    return obj;
  },

  create(base?: DeepPartial<Exception_LogContext>): Exception_LogContext {
    return Exception_LogContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Exception_LogContext>): Exception_LogContext {
    const message = createBaseException_LogContext();
    message.level = object.level ?? "";
    message.file = object.file ?? "";
    message.line = object.line ?? 0;
    message.method = object.method ?? "";
    message.hostname = object.hostname ?? "";
    message.threadName = object.threadName ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? Exception_LogContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseFeature(): Feature {
  return {
    featureDigest: "",
    subjectiveRestrictions: undefined,
    descriptionDigest: "",
    dependencies: [],
    protocolFeatureType: "",
    specification: [],
  };
}

export const Feature: MessageFns<Feature> = {
  encode(message: Feature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.featureDigest !== "") {
      writer.uint32(10).string(message.featureDigest);
    }
    if (message.subjectiveRestrictions !== undefined) {
      SubjectiveRestrictions.encode(message.subjectiveRestrictions, writer.uint32(18).fork()).join();
    }
    if (message.descriptionDigest !== "") {
      writer.uint32(26).string(message.descriptionDigest);
    }
    for (const v of message.dependencies) {
      writer.uint32(34).string(v!);
    }
    if (message.protocolFeatureType !== "") {
      writer.uint32(42).string(message.protocolFeatureType);
    }
    for (const v of message.specification) {
      Specification.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Feature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.featureDigest = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subjectiveRestrictions = SubjectiveRestrictions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.descriptionDigest = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dependencies.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.protocolFeatureType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.specification.push(Specification.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Feature {
    return {
      featureDigest: isSet(object.featureDigest) ? globalThis.String(object.featureDigest) : "",
      subjectiveRestrictions: isSet(object.subjectiveRestrictions)
        ? SubjectiveRestrictions.fromJSON(object.subjectiveRestrictions)
        : undefined,
      descriptionDigest: isSet(object.descriptionDigest) ? globalThis.String(object.descriptionDigest) : "",
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => globalThis.String(e))
        : [],
      protocolFeatureType: isSet(object.protocolFeatureType) ? globalThis.String(object.protocolFeatureType) : "",
      specification: globalThis.Array.isArray(object?.specification)
        ? object.specification.map((e: any) => Specification.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Feature): unknown {
    const obj: any = {};
    if (message.featureDigest !== "") {
      obj.featureDigest = message.featureDigest;
    }
    if (message.subjectiveRestrictions !== undefined) {
      obj.subjectiveRestrictions = SubjectiveRestrictions.toJSON(message.subjectiveRestrictions);
    }
    if (message.descriptionDigest !== "") {
      obj.descriptionDigest = message.descriptionDigest;
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies;
    }
    if (message.protocolFeatureType !== "") {
      obj.protocolFeatureType = message.protocolFeatureType;
    }
    if (message.specification?.length) {
      obj.specification = message.specification.map((e) => Specification.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Feature>): Feature {
    return Feature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Feature>): Feature {
    const message = createBaseFeature();
    message.featureDigest = object.featureDigest ?? "";
    message.subjectiveRestrictions =
      (object.subjectiveRestrictions !== undefined && object.subjectiveRestrictions !== null)
        ? SubjectiveRestrictions.fromPartial(object.subjectiveRestrictions)
        : undefined;
    message.descriptionDigest = object.descriptionDigest ?? "";
    message.dependencies = object.dependencies?.map((e) => e) || [];
    message.protocolFeatureType = object.protocolFeatureType ?? "";
    message.specification = object.specification?.map((e) => Specification.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubjectiveRestrictions(): SubjectiveRestrictions {
  return { enabled: false, preactivationRequired: false, earliestAllowedActivationTime: "" };
}

export const SubjectiveRestrictions: MessageFns<SubjectiveRestrictions> = {
  encode(message: SubjectiveRestrictions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.preactivationRequired !== false) {
      writer.uint32(16).bool(message.preactivationRequired);
    }
    if (message.earliestAllowedActivationTime !== "") {
      writer.uint32(26).string(message.earliestAllowedActivationTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubjectiveRestrictions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubjectiveRestrictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.preactivationRequired = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.earliestAllowedActivationTime = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubjectiveRestrictions {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      preactivationRequired: isSet(object.preactivationRequired)
        ? globalThis.Boolean(object.preactivationRequired)
        : false,
      earliestAllowedActivationTime: isSet(object.earliestAllowedActivationTime)
        ? globalThis.String(object.earliestAllowedActivationTime)
        : "",
    };
  },

  toJSON(message: SubjectiveRestrictions): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.preactivationRequired !== false) {
      obj.preactivationRequired = message.preactivationRequired;
    }
    if (message.earliestAllowedActivationTime !== "") {
      obj.earliestAllowedActivationTime = message.earliestAllowedActivationTime;
    }
    return obj;
  },

  create(base?: DeepPartial<SubjectiveRestrictions>): SubjectiveRestrictions {
    return SubjectiveRestrictions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubjectiveRestrictions>): SubjectiveRestrictions {
    const message = createBaseSubjectiveRestrictions();
    message.enabled = object.enabled ?? false;
    message.preactivationRequired = object.preactivationRequired ?? false;
    message.earliestAllowedActivationTime = object.earliestAllowedActivationTime ?? "";
    return message;
  },
};

function createBaseSpecification(): Specification {
  return { name: "", value: "" };
}

export const Specification: MessageFns<Specification> = {
  encode(message: Specification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Specification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpecification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Specification {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Specification): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Specification>): Specification {
    return Specification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Specification>): Specification {
    const message = createBaseSpecification();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountCreationRef(): AccountCreationRef {
  return { account: "", creator: "", blockNum: 0, blockId: "", blockTime: undefined, transactionId: "" };
}

export const AccountCreationRef: MessageFns<AccountCreationRef> = {
  encode(message: AccountCreationRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.creator !== "") {
      writer.uint32(18).string(message.creator);
    }
    if (message.blockNum !== 0) {
      writer.uint32(24).uint64(message.blockNum);
    }
    if (message.blockId !== "") {
      writer.uint32(34).string(message.blockId);
    }
    if (message.blockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.blockTime), writer.uint32(42).fork()).join();
    }
    if (message.transactionId !== "") {
      writer.uint32(50).string(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountCreationRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountCreationRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockNum = longToNumber(reader.uint64());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountCreationRef {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
      blockId: isSet(object.blockId) ? globalThis.String(object.blockId) : "",
      blockTime: isSet(object.blockTime) ? fromJsonTimestamp(object.blockTime) : undefined,
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
    };
  },

  toJSON(message: AccountCreationRef): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    if (message.blockId !== "") {
      obj.blockId = message.blockId;
    }
    if (message.blockTime !== undefined) {
      obj.blockTime = message.blockTime.toISOString();
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    return obj;
  },

  create(base?: DeepPartial<AccountCreationRef>): AccountCreationRef {
    return AccountCreationRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountCreationRef>): AccountCreationRef {
    const message = createBaseAccountCreationRef();
    message.account = object.account ?? "";
    message.creator = object.creator ?? "";
    message.blockNum = object.blockNum ?? 0;
    message.blockId = object.blockId ?? "";
    message.blockTime = object.blockTime ?? undefined;
    message.transactionId = object.transactionId ?? "";
    return message;
  },
};

function createBaseHeaderOnlyBlock(): HeaderOnlyBlock {
  return { id: "", number: 0, header: undefined, blockrootMerkle: undefined };
}

export const HeaderOnlyBlock: MessageFns<HeaderOnlyBlock> = {
  encode(message: HeaderOnlyBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.number !== 0) {
      writer.uint32(16).uint32(message.number);
    }
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(34).fork()).join();
    }
    if (message.blockrootMerkle !== undefined) {
      BlockRootMerkle.encode(message.blockrootMerkle, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderOnlyBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderOnlyBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.number = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.blockrootMerkle = BlockRootMerkle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderOnlyBlock {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      blockrootMerkle: isSet(object.blockrootMerkle) ? BlockRootMerkle.fromJSON(object.blockrootMerkle) : undefined,
    };
  },

  toJSON(message: HeaderOnlyBlock): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (message.blockrootMerkle !== undefined) {
      obj.blockrootMerkle = BlockRootMerkle.toJSON(message.blockrootMerkle);
    }
    return obj;
  },

  create(base?: DeepPartial<HeaderOnlyBlock>): HeaderOnlyBlock {
    return HeaderOnlyBlock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HeaderOnlyBlock>): HeaderOnlyBlock {
    const message = createBaseHeaderOnlyBlock();
    message.id = object.id ?? "";
    message.number = object.number ?? 0;
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.blockrootMerkle = (object.blockrootMerkle !== undefined && object.blockrootMerkle !== null)
      ? BlockRootMerkle.fromPartial(object.blockrootMerkle)
      : undefined;
    return message;
  },
};

function createBaseTransactionTraceWithBlockRef(): TransactionTraceWithBlockRef {
  return { trace: undefined, blockRef: undefined };
}

export const TransactionTraceWithBlockRef: MessageFns<TransactionTraceWithBlockRef> = {
  encode(message: TransactionTraceWithBlockRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace !== undefined) {
      TransactionTrace.encode(message.trace, writer.uint32(10).fork()).join();
    }
    if (message.blockRef !== undefined) {
      BlockRef.encode(message.blockRef, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionTraceWithBlockRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionTraceWithBlockRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trace = TransactionTrace.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockRef = BlockRef.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionTraceWithBlockRef {
    return {
      trace: isSet(object.trace) ? TransactionTrace.fromJSON(object.trace) : undefined,
      blockRef: isSet(object.blockRef) ? BlockRef.fromJSON(object.blockRef) : undefined,
    };
  },

  toJSON(message: TransactionTraceWithBlockRef): unknown {
    const obj: any = {};
    if (message.trace !== undefined) {
      obj.trace = TransactionTrace.toJSON(message.trace);
    }
    if (message.blockRef !== undefined) {
      obj.blockRef = BlockRef.toJSON(message.blockRef);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionTraceWithBlockRef>): TransactionTraceWithBlockRef {
    return TransactionTraceWithBlockRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionTraceWithBlockRef>): TransactionTraceWithBlockRef {
    const message = createBaseTransactionTraceWithBlockRef();
    message.trace = (object.trace !== undefined && object.trace !== null)
      ? TransactionTrace.fromPartial(object.trace)
      : undefined;
    message.blockRef = (object.blockRef !== undefined && object.blockRef !== null)
      ? BlockRef.fromPartial(object.blockRef)
      : undefined;
    return message;
  },
};

function createBaseBlockRef(): BlockRef {
  return { hash: new Uint8Array(0), number: 0 };
}

export const BlockRef: MessageFns<BlockRef> = {
  encode(message: BlockRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (message.number !== 0) {
      writer.uint32(16).uint64(message.number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.number = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockRef {
    return {
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
    };
  },

  toJSON(message: BlockRef): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockRef>): BlockRef {
    return BlockRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockRef>): BlockRef {
    const message = createBaseBlockRef();
    message.hash = object.hash ?? new Uint8Array(0);
    message.number = object.number ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
